<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Computer Science Notes - My notes on CS Level 3</title>
    <meta name="description" content="My CS notes" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/cs-notes/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/cs-notes/assets/css/main.css" />

</head>
<body class="home-template">

    <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="back-button icon-arrow-left" href="/cs-notes">Home</a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Algorithmics 1</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2018-01-10">10 Jan 2018</time>
                
                    on Level3 and Semester1
                
            </section>
            <br>
            <br>
        </header>

<!--         <header class="post-header">
            <a id="blog-logo" href="http://localhost:4000">
                
                    <span class="blog-title">Computer Science Notes</span>
                
            </a>
        </header> -->

        <!-- <span class="post-meta">
            <time datetime="2018-01-10">10 Jan 2018</time>
            
                on Level3 and Semester1
            
        </span> -->

        <!-- <h1 class="post-title">Algorithmics 1</h1> -->

        <section class="post-content">
            <h5 id="useful-textbooks">Useful Textbooks</h5>

<ul>
  <li>M.T. Goodrich &amp; R. Tamassia, Algorithm Design: Foundations, Analysis, and Internet Examples, Wiley, 2002</li>
  <li>D. Harel &amp; Y. Feldman, Algorithmics: the Spirit of Computing, Addison Wesley, 2004 (also earlier 1992 edition by D. Harel)</li>
  <li>M. Sipser, Introduction to the Theory of Computation, Course Technology, 2006
<!--excerpt--></li>
</ul>

<h3 id="contents">Contents</h3>

<p><a href="#section_0">Introduction</a><br />
   <a href="#section_1">Fundamental Algorithms and Data Structures</a><br />
   <a href="#section_2">Sorting Algorithms</a><br />
   <a href="#section_3">Strings and text algorithms</a><br />
   <a href="#section_4">Graphs and graph algorithms</a><br />
   <a href="#section_5">NP Completeness</a><br />
   <a href="#section_6">Computability</a></p>

<p><a name="section_0"></a></p>

<h4 id="introduction">Introduction</h4>

<h5 id="revision---algorithm-analysis">Revision - Algorithm Analysis</h5>

<ul>
  <li>Time and space complexity is written as a function of input size</li>
  <li>Worst case - gives a guarantee of algorithm’s performance</li>
  <li>Asymptotic behaviour indicates what will happen as input size grows</li>
  <li>Expressed using Big O notation</li>
</ul>

<h6 id="big-o-notation">Big O notation</h6>

<ul>
  <li><code class="highlighter-rouge">f(n) = O(g(n))</code></li>
  <li><code class="highlighter-rouge">f</code> grows no faster than <code class="highlighter-rouge">g</code></li>
  <li>there exists a real constant <code class="highlighter-rouge">c</code> and integer constant <code class="highlighter-rouge">N</code> such that <code class="highlighter-rouge">|f(n)| &lt;= |c*g(n)|</code> for all <code class="highlighter-rouge">n =&gt; N</code></li>
  <li><code class="highlighter-rouge">f</code> is usually a complex function, which is not known precisely</li>
  <li><code class="highlighter-rouge">g</code> is a known function eg O(1), O(n) etc</li>
  <li>use the “tightest” <code class="highlighter-rouge">g</code> we can find for an algorithm</li>
</ul>

<h6 id="log-function">Log function</h6>

<ul>
  <li>x = log<sub>a</sub>n if n = a<sup>x</sup></li>
  <li>log<sub>a</sub> m * n = log<sub>a</sub>m + log<sub>a</sub>n</li>
  <li>log<sub>a</sub> m / n = log<sub>a</sub>m - log<sub>a</sub>n</li>
  <li>log<sub>a</sub>n<sup>c</sup> = c * log<sub>a</sub>n</li>
</ul>

<h6 id="time-complexities">Time complexities</h6>

<p><strong>For some constant <code class="highlighter-rouge">c</code>:</strong></p>

<ul>
  <li>Polynomial-time = O(n<sup>c</sup>)</li>
  <li>Exponential-time = no better than O(c<sup>n</sup>) where <code class="highlighter-rouge">c &gt; 1</code></li>
</ul>

<p><a name="section_1"></a></p>

<h4 id="fundamental-algorithms-and-data-structures">Fundamental Algorithms and Data Structures</h4>

<ul>
  <li><a href="#stack_topic">Stacks</a>, <a href="#queue_topic">queues</a> and <a href="#priority_queue_topic">priority queues</a></li>
  <li><a href="#cbt_topic">Complete binary trees</a></li>
  <li><a href="#heap_topic">Heaps and heap operations</a></li>
  <li><a href="#java_heap">Java class</a> for (integer) heaps</li>
  <li><a href="#heap_sort_topic">Heap sort</a></li>
</ul>

<p><a name="stack_topic"></a></p>

<h5 id="stack-abstract-data-type-lifo">Stack abstract data type (LIFO)</h5>

<p><strong>Basic operations:</strong></p>

<ul>
  <li><em>create</em></li>
  <li><em>isEmpty</em></li>
  <li><em>push</em> (to top of stack)</li>
  <li><em>pop</em> (delete and return from top of stack)</li>
</ul>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>an array - all operations are O(1)</li>
  <li>a linked list - all operations are O(1)</li>
</ul>

<p><a name="queue_topic"></a></p>

<h5 id="queue-abstract-data-type-fifo">Queue abstract data type (FIFO)</h5>

<p><strong>Basic operations:</strong></p>

<ul>
  <li><em>create</em></li>
  <li><em>isEmpty</em></li>
  <li><em>insert</em> (to the back of queue)</li>
  <li><em>delete</em> (delete and return item at front of queue)</li>
</ul>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>an array - all operations are O(1) and it must be “wrapped around”, treated as circular</li>
  <li>a linked list - all operations are O(1)</li>
</ul>

<p><a name="priority_queue_topic"></a></p>

<h5 id="priority-queue-abstract-data-type">Priority queue abstract data type</h5>

<p><strong>Basic operations:</strong></p>

<ul>
  <li><em>create</em></li>
  <li><em>isEmpty</em></li>
  <li><em>insert</em> (new item with given priority)</li>
  <li><em>delete</em> (delete and return item with highest priority)</li>
</ul>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>unordered list - <em>insert</em> O(1), <em>delete</em> O(n)</li>
  <li>ordered list - <em>insert</em> O(n), <em>delete</em> O(1)</li>
  <li>heap - <em>insert</em> and <em>delete</em> are O(logn)</li>
  <li>in all cases <em>create</em> and <em>isEmpty</em> are O(1)</li>
</ul>

<p><a name="cbt_topic"></a></p>

<h5 id="complete-binary-trees">Complete Binary Trees</h5>

<p><strong>Height of a node:</strong></p>

<ul>
  <li>length of the longest path from the node to a leaf</li>
  <li>height of a heap is the height of its root node</li>
  <li>a binary tree of height <code class="highlighter-rouge">h</code> can contain maximum 2<sup>h+1</sup> - 1 nodes</li>
  <li>therefore the height of a CBT with <code class="highlighter-rouge">n</code> nodes is é log<sub>2</sub>( n + 1 ) - 1 ù</li>
</ul>

<p><strong>A complete binary tree with <code class="highlighter-rouge">n</code> nodes has:</strong></p>

<ul>
  <li>the minimum possible height</li>
  <li>the maximum possible number of nodes at each level <em>except the last</em> (ie for <code class="highlighter-rouge">i = 0, ... , h - 2</code>, level <code class="highlighter-rouge">i</code> has 2<sup>i</sup> nodes</li>
  <li>the nodes on the <em>last</em> level are as far to the left as possible</li>
</ul>

<p><strong>Properties of a CBT:</strong></p>

<ul>
  <li>with a height <code class="highlighter-rouge">h</code>, it has at <em>most</em> 2<sup>h+1</sup> - 1 nodes</li>
  <li>with <code class="highlighter-rouge">n</code> nodes, its height is é log<sub>2</sub>( n + 1 ) - 1 ù</li>
  <li>then it has é n / 2 ù leaf nodes</li>
  <li>and it has ⌊ n / 2 ⌋ branch nodes</li>
</ul>

<p><a name="heap_topic"></a></p>

<h5 id="heaps">Heaps</h5>

<p><strong>Def:</strong> A CBT where each node stores an item, and has a priority value<br />
   <strong>Heap property:</strong> Every node’s priority is greater than or equal to the priorities of all its descendent nodes<br />
   <strong>Min-heap:</strong> Inverted so that the minimum priority is at the root
<br />
<br />
<strong>For a node <code class="highlighter-rouge">i</code>:</strong></p>

<ul>
  <li>its children are nodes <code class="highlighter-rouge">2i + 1</code> and <code class="highlighter-rouge">2i + 2</code></li>
  <li>its parent is the node <code class="highlighter-rouge">⌊ (i - 1) / 2 ⌋</code></li>
</ul>

<p><strong>Basic operations:</strong></p>

<ul>
  <li><em>insert</em> an item</li>
  <li><em>build</em> a heap containing a given set of items</li>
  <li><em>delete</em> the item with highest priority</li>
  <li><em>impose</em> the heap property on a given node</li>
</ul>

<p><strong>Complexity:</strong></p>

<ul>
  <li><em>build</em> is O(n log n) and there is an O(n) alternative</li>
  <li>all other operations are O(log n) for algorithms which take O(1) steps at each level of the heap</li>
</ul>

<p><strong>Insertion:</strong><br />
   <code class="highlighter-rouge">while (new_value NOT in root &amp;&amp; new_value &gt; parent_value)  
   swap new_value with parent_value</code><br />
   <strong>Imposing:</strong><br />
   Pre-condition - a specified node may violate the heap property, but all its descendents satisfy the property<br />
   Post-condition - the specified node and all of its descendents satisfy the property<br />
   <code class="highlighter-rouge">while (bad_value NOT in leaf &amp;&amp; bad_value &lt; larger_child)  
   swap bad_value with larger_child</code><br />
   <strong>Deletion:</strong><br />
   <code class="highlighter-rouge">swap root with node in last (bottom-right) leaf  
delete last leaf  
impose heap property on bad value now in root</code><br />
   <strong>Building:</strong><br />
   Pre-condition - values are in arbitrary order<br />
   Post-condition - values form a heap<br />
   <code class="highlighter-rouge">for each non-leaf node in bottom-to-top right-to-left order  
   impose heap propery</code></p>

<p><a name="java_heap"></a></p>

<h5 id="an-integer-heap-class">An integer heap class</h5>

<p>Represent using an array, where:</p>

<ul>
  <li>children of a node <code class="highlighter-rouge">i</code> are in the array at <code class="highlighter-rouge">2i + 1</code> and <code class="highlighter-rouge">2i + 2</code></li>
  <li>parent of a node <code class="highlighter-rouge">i</code> are in the array at <code class="highlighter-rouge">(i - 1) / 2</code> (floored automatically in Java)</li>
</ul>

<p>Heap class <a href="#heap_class">implementation in Java</a></p>

<p><a name="heap_sort_topic"></a></p>

<h5 id="heap-sort">Heap Sort</h5>

<ul>
  <li>more efficient than selection sort</li>
  <li>O(n log n) in the worst case</li>
  <li><a href="#heap_sort">pseudocode</a></li>
</ul>

<p><a name="section_2"></a></p>

<h4 id="sorting-algorithms">Sorting Algorithms</h4>

<ul>
  <li><a href="#comparison_topic">Comparison-based sorting</a></li>
  <li><a href="#radix_topic">Radix</a> sort</li>
  <li><a href="#trie_topic">Tries</a> (re<strong>trie</strong>val)</li>
</ul>

<p><strong>Common sorts:</strong><br />
   O(n<sup>2</sup>) - selection, insertion, bubble<br />
   O(n log n) - merge, heap<br />
   Quicksort is O(n log n) on average (but no better than O(n<sup>2</sup>) in the worst case</p>

<p><a name="comparison_topic"></a></p>

<h5 id="comparison-based-sorting">Comparison-based sorting</h5>

<p><strong>Claim:</strong> No sorting algorithm that is based on pairwise comparison can be better than O(n log n) in the worst case<br />
   <strong>Justification:</strong> Draw out the algorithm using a binary decision tree, where each node represents a comparison between two elements</p>

<ul>
  <li>leaf nodes represent the possible outcomes of the algorithm</li>
  <li>so the number of leaf nodes = the possible ordering of <code class="highlighter-rouge">n</code> items</li>
  <li>so there are at least <code class="highlighter-rouge">n!</code> and maximum 2<sup>h+1</sup> leaf nodes</li>
  <li>its worst case complexity is O(h) where <code class="highlighter-rouge">h</code> = its height</li>
  <li>it follows that n! &lt;= 2<sup>h+1</sup></li>
</ul>

<p><img src="/cs-notes/assets/images/algs/decision_tree.png" nopin="nopin" /></p>

<p>Reversing inequality and taking log<sub>2</sub> of both sides:</p>

<p><img src="/cs-notes/assets/images/algs/comparison_based_complexity.png" nopin="nopin" /></p>

<p>Giving a complexity of O(n log n) as required</p>

<p><a name="radix_topic"></a></p>

<h5 id="radix-sorting">Radix sorting</h5>

<ul>
  <li>O(n) complexity</li>
  <li>exploits the structure of items to be sorted to achieve this</li>
  <li>faster than O(n log n) only for very large <code class="highlighter-rouge">n</code></li>
</ul>

<p><strong>How it works:</strong></p>

<ul>
  <li>each iteration the items are distributed into buckets (lists)</li>
  <li>during an <code class="highlighter-rouge">i</code><sup>th</sup> iteration an item is placed in the bucket corresponding to the integer represented by its bits</li>
  <li>at the end of an iteration the buckets are concatenated to give a new sequence which will be used as the starting point of the next iteration</li>
  <li>there are <code class="highlighter-rouge">m / b</code> iterations, where <code class="highlighter-rouge">m</code> is the length of bit-sequences representing an item, and <code class="highlighter-rouge">b</code> is a chosen factor of <code class="highlighter-rouge">m</code></li>
</ul>

<p>To sort the following sequence: <code class="highlighter-rouge">15 43 5 27 60 18 26 2</code><br />
   Where binary encodings are given by:<br />
   <code class="highlighter-rouge">15 = 001111  43 = 101011  5 = 000101  27 = 011011</code><br />
   <code class="highlighter-rouge">60 = 111100  18 = 010010  26 = 011010  2 = 000010</code></p>

<p>Items have bit positions 0, …, 5 so <code class="highlighter-rouge">m</code> = 6<br />
   <code class="highlighter-rouge">b</code> must be a factor of <code class="highlighter-rouge">m</code>, so choose <code class="highlighter-rouge">b</code> = 2<br />
   So we have 2<sup>b</sup> = 2<sup>2</sup> = 4 buckets labelled 0, 1, 2, 3 (or 00, 01, 10, 11)
   And <code class="highlighter-rouge">m / b = 3</code> iterations are required</p>

<p>See radix sorting pseudocode <a href="#radix_sort">here</a></p>

<p><strong>Correctness:</strong> For two items <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> where <code class="highlighter-rouge">x &lt; y</code>, we need to show that <code class="highlighter-rouge">x</code> precedes <code class="highlighter-rouge">y</code> in the final sequence</p>

<p><strong>During the last iteration</strong> where some bits of <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> differ:</p>

<ul>
  <li>the bits of <code class="highlighter-rouge">x</code> must be smaller than <code class="highlighter-rouge">y</code></li>
  <li>so <code class="highlighter-rouge">x</code> goes into a bucket before <code class="highlighter-rouge">y</code> does</li>
  <li>so <code class="highlighter-rouge">x</code> precedes <code class="highlighter-rouge">y</code> in the sequence after this iteration</li>
  <li>in later iterations, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> go in the same bucket as they don’t have any more differing bits</li>
</ul>

<p><strong>Complexity:</strong></p>

<ul>
  <li>during each of the <code class="highlighter-rouge">m / b</code> iterations, the sequence is scanned –&gt; O(n) time, and buckets are concatenated –&gt; O(2<sup>b</sup>) time</li>
  <li>overall, O(m / b (n + 2<sup>b</sup>)) –&gt; O(n)</li>
</ul>

<p><strong>Time-space trade-off:</strong></p>

<ul>
  <li>the larger the value of b, the smaller the multiplicative constant (m / b) in the complexity function and so the faster the algorithm will become</li>
  <li>an array of size 2<sup>b</sup> is required, so increasing <code class="highlighter-rouge">b</code> will increase space requirements</li>
</ul>

<p><a name="trie_topic"></a></p>

<h5 id="tries">Tries</h5>

<ul>
  <li>stored items have a key that is interpreted as a sequence of bits/characters</li>
  <li>there is a multiway branch at each node where each branch has an associated symbol</li>
  <li>no two siblings have the same symbol</li>
  <li>the branch to be taken at level <code class="highlighter-rouge">i</code> is determined by the <code class="highlighter-rouge">i</code><sup>th</sup> element of the key</li>
  <li>tracing a path from root to a node spells out the key of the item</li>
  <li>eg, used to store strings</li>
</ul>

<p><img src="/cs-notes/assets/images/algs/trie.png" nopin="nopin" /></p>

<p><em>Search</em> and <em>insert</em> algorithms for the trie found <a href="#trie_alg">here</a></p>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>an array of pointers, which represent children</li>
  <li>linked lists, containing children of each node</li>
</ul>

<p><img src="/cs-notes/assets/images/algs/trie_list.png" nopin="nopin" /></p>

<p><a href="#trie_class">Example</a> trie class to represent a dictionary</p>

<p><a name="section_3"></a></p>

<h4 id="strings-and-text-algorithms">Strings and text algorithms</h4>

<ul>
  <li><a href="#compression_topic">Text compression</a>
    <ul>
      <li><a href="#huffman_topic">Huffman</a> and <a href="#lzw_topic">LZW</a></li>
    </ul>
  </li>
  <li><a href="#string_comparison_topic">String comparison</a>
    <ul>
      <li><a href="#string_distance_topic">String distance</a></li>
    </ul>
  </li>
  <li><a href="#pattern_topic">String/pattern search</a>
    <ul>
      <li><a href="#brute_topic">Brute force</a></li>
      <li><a href="#kmp_topic">KMP</a></li>
      <li><a href="#bm_topic">BM</a></li>
    </ul>
  </li>
</ul>

<p><a name="compression_topic"></a></p>

<h5 id="text-compression">Text compression</h5>

<ul>
  <li>lossless</li>
  <li>compression ratio is <code class="highlighter-rouge">x / y</code> where <code class="highlighter-rouge">x</code> = compressed and <code class="highlighter-rouge">y</code> = original</li>
  <li>space saved = <code class="highlighter-rouge">1 - (x / y) * 100%</code></li>
</ul>

<p><a name="huffman_topic"></a></p>

<h5 id="huffman-encoding">Huffman encoding</h5>

<ul>
  <li>statistical method</li>
  <li>unique, variable-length codeword for each character</li>
  <li>no codeword is the prefix of another</li>
  <li>each character is a leaf node</li>
  <li>codeword is the path from root to appropriate leaf</li>
  <li>when going down the path, left route = 0, right route = 1</li>
</ul>

<p><strong>Huffman tree construction:</strong></p>

<ul>
  <li>add leaf nodes containing the character represented and its frequency</li>
  <li>while there are &gt; 1 parentless nodes
    <ul>
      <li>add new parent to the two nodes of smallest weight (frequency)</li>
      <li>weight of the parent node = sum of child weights</li>
    </ul>
  </li>
</ul>

<p>The tree for a file with char frequencies:<br />
   <code class="highlighter-rouge">Space = 15  E = 11  A = 9  T = 8  I = 7  S = 7</code><br />
   <code class="highlighter-rouge">R = 7  O = 6  N = 4  U = 3  H = 2  C = 1  D = 1</code></p>

<p><img src="/cs-notes/assets/images/algs/huffman_1.png" nopin="nopin" /></p>

<p>Tree construction <a href="#huff_contruct">pseudocode</a></p>

<p><strong>Generating the codewords:</strong></p>

<ul>
  <li>following left and right paths down the constructed tree
    <ul>
      <li>Space <code class="highlighter-rouge">10</code></li>
      <li>E <code class="highlighter-rouge">010</code></li>
      <li>A <code class="highlighter-rouge">111</code></li>
      <li>T <code class="highlighter-rouge">110</code></li>
      <li>I <code class="highlighter-rouge">0000</code></li>
      <li>S <code class="highlighter-rouge">0001</code></li>
      <li>R <code class="highlighter-rouge">0011</code></li>
      <li>O <code class="highlighter-rouge">0110</code></li>
      <li>N <code class="highlighter-rouge">0111</code></li>
      <li>U <code class="highlighter-rouge">00101</code></li>
      <li>H <code class="highlighter-rouge">001001</code></li>
      <li>C <code class="highlighter-rouge">0010000</code></li>
      <li>D <code class="highlighter-rouge">0010001</code></li>
    </ul>
  </li>
</ul>

<p><strong>Weighted path length of tree T:</strong></p>

<ul>
  <li><code class="highlighter-rouge">SUM( weight * distance from root )</code></li>
  <li>sum is over all leaf nodes</li>
  <li>this gives the number of bits in the compressed file</li>
</ul>

<p><strong>Complexity:</strong></p>

<ul>
  <li>building tree - O(n)</li>
  <li>compression - O(n)</li>
  <li>decompression - O(n)</li>
  <li>use <strong>adaptive</strong> Huffman coding
    <ul>
      <li>same tree built and adapted by compressor and decompressor</li>
    </ul>
  </li>
</ul>

<p><a name="lzw_topic"></a></p>

<h5 id="lzw-compression">LZW compression</h5>

<ul>
  <li>dictionary method</li>
  <li>collection of strings, each with a bit pattern that represents it</li>
  <li>dictionary built dynamically during compression and decompression</li>
  <li>if string <code class="highlighter-rouge">s</code> is represented, so is every prefix of <code class="highlighter-rouge">s</code></li>
  <li>a <strong>trie</strong> is an ideal representation</li>
</ul>

<p>At any given time during comp./decomp. there is a <strong>current codeword length <code class="highlighter-rouge">k</code></strong>:</p>

<ul>
  <li>2<sup>k</sup> distinct codewords available</li>
  <li>limits size of dictionary, but can be incremented as necessary (so doubling the codeword availability)</li>
  <li>initial <code class="highlighter-rouge">k</code> should be large enough to encode all strings of length <code class="highlighter-rouge">l</code></li>
</ul>

<p>LZW compression <a href="#lzw">pseudocode</a></p>

<p><img src="/cs-notes/assets/images/algs/lzw_1.png" nopin="nopin" /></p>

<p><strong>LZW variants:</strong></p>

<ul>
  <li>constant - fixed capacity dictionary</li>
  <li>dynamic - add 1 to current length whenever dictionary becomes full</li>
  <li>LRU - when full, current string replaces the least recently used string in the dictionary</li>
</ul>

<p><strong>LZW decompression:</strong></p>

<ul>
  <li>builds same dictionary as compression but <strong>1 step out of phase</strong></li>
  <li>may encounter codeword that is not in dictionary
    <ul>
      <li>if (lookup fails) newS = oldS + oldS.charAt(0);</li>
    </ul>
  </li>
</ul>

<p>LZW decompression <a href="#lzw_decomp">pseudocode</a></p>

<p><img src="/cs-notes/assets/images/algs/lzw_2.png" nopin="nopin" /></p>

<p><strong>Complexity:</strong> O(n) for comp. and decomp. each</p>

<p><a name="string_comparison_topic"></a></p>

<h5 id="string-comparison">String comparison</h5>

<ul>
  <li>given strings <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">t</code> of lengths <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, what is the smallest number of basic operations needed to transform <code class="highlighter-rouge">s</code> into <code class="highlighter-rouge">t</code>?</li>
  <li>use
    <ul>
      <li>insertion</li>
      <li>deletion</li>
      <li>subsitution</li>
    </ul>
  </li>
</ul>

<p><strong>String distance:</strong></p>

<p><img src="/cs-notes/assets/images/algs/distance_1.png" nopin="nopin" /></p>

<p><strong>Prefixes:</strong></p>

<ul>
  <li><code class="highlighter-rouge">i</code><sup>th</sup> prefix of string <code class="highlighter-rouge">s</code> is first <code class="highlighter-rouge">i</code> chars of <code class="highlighter-rouge">s</code></li>
  <li>let <code class="highlighter-rouge">d( i,j )</code> = distance between prefix <code class="highlighter-rouge">i</code> of <code class="highlighter-rouge">s</code> and prefix <code class="highlighter-rouge">j</code> of <code class="highlighter-rouge">t</code></li>
  <li>then distance between <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">t</code> = <code class="highlighter-rouge">d( m,n )</code> for <code class="highlighter-rouge">len(s) = m</code> and <code class="highlighter-rouge">len(t) = n</code></li>
</ul>

<p><strong>Optimal alignment:</strong></p>

<p>The last position of the alignment must either be of the form<br />
   <img src="/cs-notes/assets/images/algs/optimal_alignment.png" nopin="nopin" /></p>

<p>In other words,<br />
   <img src="/cs-notes/assets/images/algs/optimal_alignment_alt.png" nopin="nopin" /></p>

<p><a name="string_distance_topic"></a></p>

<h5 id="distance-with-dynamic-programming">Distance with dynamic programming</h5>

<ul>
  <li>fill in entries of an <code class="highlighter-rouge">m * n</code> table row by row, and column by column</li>
  <li>time and space complexity = O(mn)</li>
  <li>keep most recent entry in each column of the table
    <ul>
      <li>space complexity = O(m + n)</li>
    </ul>
  </li>
</ul>

<p><strong>Distances table:</strong></p>

<p><img src="/cs-notes/assets/images/algs/distance_table.png" nopin="nopin" /></p>

<ul>
  <li>entries calculated one by one by applying formula above</li>
  <li>final entry <code class="highlighter-rouge">d( 7,8 ) = 4</code> so string distance is <strong>4</strong></li>
  <li>trace back to entry <code class="highlighter-rouge">( 0,0 )</code> to find optimal alignment
    <ul>
      <li>vertical = deletion</li>
      <li>horizontal = insertion</li>
      <li>diagonal = match/substitution</li>
    </ul>
  </li>
</ul>

<p><a name="pattern_topic"></a></p>

<h5 id="stringpattern-search">String/pattern search</h5>

<p>Given a text <code class="highlighter-rouge">t</code> of length <code class="highlighter-rouge">n</code>, and a string/pattern <code class="highlighter-rouge">s</code> of length <code class="highlighter-rouge">m</code>, find the position of the last occurence of <code class="highlighter-rouge">s</code> in <code class="highlighter-rouge">t</code></p>

<p><a name="brute_topic"></a></p>

<h5 id="brute-force-algorithm">Brute force algorithm</h5>

<ul>
  <li>current starting position in text = 0</li>
  <li>compare chars from <code class="highlighter-rouge">s</code> and <code class="highlighter-rouge">t</code> left to right until the entire string is matched</li>
  <li>if mismatch, advance starting position by 1 and repeat</li>
</ul>

<p>Brute force <a href="#brute_force">pseudocode</a></p>

<p><strong>Effectiveness:</strong></p>

<ul>
  <li>expressed using char arrays rather than strings in Java</li>
  <li><code class="highlighter-rouge">m</code> char comparisons needed at each <code class="highlighter-rouge">n - (m + 1)</code> positions in text before the pattern is found</li>
  <li>worse case O(mn)</li>
  <li>average case O(n)</li>
</ul>

<p><a name="kmp_topic"></a></p>

<h5 id="kmp-algorithm">KMP algorithm</h5>

<ul>
  <li>online - removes need to back-up in text</li>
  <li>worst case O(n)</li>
  <li>need to pre-process the string into a border table (an array <code class="highlighter-rouge">b</code> with an entry <code class="highlighter-rouge">b[j]</code> for each position <code class="highlighter-rouge">j</code>)</li>
  <li>if mismatch at <code class="highlighter-rouge">j</code>, remain at current text char</li>
  <li>the border table says what to compare next</li>
</ul>

<p><strong>Border of a string <code class="highlighter-rouge">s</code>:</strong></p>

<ul>
  <li>a substring that
    <ul>
      <li>is a prefix</li>
      <li>is a suffix</li>
      <li>cannot be the string itself</li>
    </ul>
  </li>
  <li>eg for string <code class="highlighter-rouge">s = a c a c g a t a c a c</code>
    <ul>
      <li>borders are <code class="highlighter-rouge">ac</code> and <code class="highlighter-rouge">acac</code></li>
      <li><code class="highlighter-rouge">acac</code> is the longest border</li>
    </ul>
  </li>
</ul>

<p><strong>Border table:</strong></p>

<p><img src="/cs-notes/assets/images/algs/border_table.png" nopin="nopin" /></p>

<ul>
  <li><code class="highlighter-rouge">b[j]</code> is
    <ul>
      <li>the length of the longest border of <code class="highlighter-rouge">s[0...j-1]</code></li>
      <li><code class="highlighter-rouge">max { k | s[0...k-1] = s[j-k...j-1] }</code></li>
    </ul>
  </li>
</ul>

<p><strong>KMP seach :</strong></p>

<ul>
  <li><a href="#kmp">implementation</a></li>
  <li>this is O(n) worst case</li>
  <li>naive method requires O(j<sup>2</sup>) steps to find <code class="highlighter-rouge">b[j]</code>, so O(m<sup>2</sup>) overall</li>
  <li>can be implemented in O(m + n) time (to set up border table and to conduct search)</li>
</ul>

<p><a name="bm_topic"></a></p>

<h5 id="boyer-moore-algorithm">Boyer-Moore algorithm</h5>

<ul>
  <li>string scanned left-to-right</li>
  <li>mismatched char used to decide next comparison</li>
  <li>need to pre-process string to record position of last occurence of each char in the alphabet</li>
  <li>alphabet must be fixed in advance of search</li>
</ul>

<p><strong>Position of last occurence of char <code class="highlighter-rouge">c</code> in string <code class="highlighter-rouge">s</code>:</strong></p>

<ul>
  <li><code class="highlighter-rouge">max { k | s[k] = c }</code> if such a <code class="highlighter-rouge">k</code> exists, <code class="highlighter-rouge">-1</code> otherwise</li>
  <li>store last occurence position of <code class="highlighter-rouge">c</code> in array element <code class="highlighter-rouge">p[c]</code></li>
</ul>

<p><strong>Jump steps on a mismatch:</strong></p>

<ul>
  <li>if mismatch between <code class="highlighter-rouge">s[j]</code> and <code class="highlighter-rouge">t[i]</code>, move <code class="highlighter-rouge">s</code> along so <code class="highlighter-rouge">p[t[i]]</code> of <code class="highlighter-rouge">s</code> aligns with <code class="highlighter-rouge">t[i]</code></li>
  <li>if this moves <code class="highlighter-rouge">s</code> in the “wrong direction”, instead move <code class="highlighter-rouge">s</code> one position to the right</li>
  <li>if <code class="highlighter-rouge">t[i]</code> doesn’t appear in the string, slide the string past <code class="highlighter-rouge">t[i]</code></li>
</ul>

<p><strong>Jump step cases:</strong></p>

<ol>
  <li><code class="highlighter-rouge">p[t[i]] &lt; j and =&gt; 0</code>
    <ul>
      <li>new <code class="highlighter-rouge">i = i + m - 1 - p[t[i]]</code></li>
      <li>new <code class="highlighter-rouge">j = m - 1</code></li>
      <li>new <code class="highlighter-rouge">sp = sp + j - p[t[i]]</code> (starting position)</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">p[t[i]] &gt; j</code>
    <ul>
      <li>new <code class="highlighter-rouge">i = i + m - j</code></li>
      <li>new <code class="highlighter-rouge">j = m - 1</code></li>
      <li>new <code class="highlighter-rouge">sp = sp + 1</code></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">p[t[i]] = -1</code>
    <ul>
      <li>new <code class="highlighter-rouge">i = i + m</code></li>
      <li>new <code class="highlighter-rouge">j = m - 1</code></li>
      <li>new <code class="highlighter-rouge">sp = sp + j + 1</code></li>
    </ul>
  </li>
</ol>

<p>BM <a href="#bm">implementation</a></p>

<p><strong>BM complexity:</strong></p>

<ul>
  <li>worst case O(mn)</li>
  <li>search for <code class="highlighter-rouge">s = ab...aa</code> of length <code class="highlighter-rouge">m</code> in <code class="highlighter-rouge">t = aa...aaaa..aa</code> of length <code class="highlighter-rouge">n</code></li>
  <li><code class="highlighter-rouge">m - 1</code> char comparisons needed at each <code class="highlighter-rouge">n - (m + 1)</code> positions in text</li>
</ul>

<p><a name="section_4"></a></p>

<h4 id="graphs-and-graph-algorithms">Graphs and graph algorithms</h4>

<ul>
  <li><a href="#graph_basics_topic">Graph basics</a></li>
  <li><a href="#graph_representations_topic">Graph representations</a></li>
  <li><a href="#graph_search_topic">Searching and traversal</a></li>
  <li><a href="#graph_weight_topic">Weighted graphs</a></li>
  <li><a href="#topological_topic">Topological ordering</a></li>
</ul>

<p><a name="graph_basics_topic"></a></p>

<h5 id="graph-basics">Graph basics</h5>

<p><strong>Undirected graphs:</strong></p>

<ul>
  <li><code class="highlighter-rouge">G = (V,E)</code></li>
  <li>each vertex is a point</li>
  <li>each edge is a line joining a pair of vertices</li>
</ul>

<p><strong>Connected:</strong> every vertex pair is joined by a path<br />
   <strong>Non-connected:</strong> graph has 2+ connected components<br />
   <strong>Tree:</strong> connected and acyclic (no cycles)<br />
   <strong>Forest:</strong> acyclic and components are trees<br />
   <strong>Complete (clique):</strong> every vertex pair is joined by an edge<br />
   <strong>Bipartite:</strong> vertices are in two dijoint sets <code class="highlighter-rouge">U</code> and <code class="highlighter-rouge">W</code> and <strong>every</strong> edge joins a vertex in <code class="highlighter-rouge">U</code> to one in <code class="highlighter-rouge">W</code></p>

<p><img src="/cs-notes/assets/images/algs/undirected_1.png" nopin="nopin" /></p>

<p>For the graphs above:</p>

<ul>
  <li>adjacent - <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">a,z</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">Î</span><span class="w"> </span><span class="err">E</span></code></li>
  <li>non-adjacent - <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">a,b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">∉</span><span class="w"> </span><span class="err">E</span></code></li>
  <li><code class="highlighter-rouge">a</code> is <strong>incident to</strong> edge <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">a,z</span><span class="w"> </span><span class="p">}</span></code></li>
  <li><code class="highlighter-rouge">a, x, b, y, c</code> is a path of length 4</li>
  <li><code class="highlighter-rouge">a, x, b, y, a</code> is a cycle of length 4</li>
  <li>all vertices have <strong>degree</strong> 3</li>
</ul>

<p><strong>Directed graphs (digraphs):</strong></p>

<ul>
  <li><code class="highlighter-rouge">D = (V,E)</code> where <code class="highlighter-rouge">V</code> and <code class="highlighter-rouge">E</code> are <strong>finite</strong> sets</li>
  <li>edges are ordered pairs</li>
  <li>drawn as arrows</li>
  <li>vertices have <strong>in-degrees</strong> and <strong>out-degrees</strong></li>
  <li>paths and cycles must follow edge directions</li>
</ul>

<p><img src="/cs-notes/assets/images/algs/directed_1.png" nopin="nopin" /></p>

<p>In the graph above:</p>

<ul>
  <li><code class="highlighter-rouge">u</code> is adjacent <strong>to</strong> <code class="highlighter-rouge">v</code></li>
  <li><code class="highlighter-rouge">v</code> is ajdacent <strong>from</strong> <code class="highlighter-rouge">u</code></li>
  <li><code class="highlighter-rouge">y</code> has in-degree 2 and out-degree 1</li>
</ul>

<p><a name="graph_representations_topic"></a></p>

<h5 id="graph-representations">Graph representations</h5>

<p><strong>Representing the undirected graph G:</strong></p>

<p><img src="/cs-notes/assets/images/algs/undirected_2.png" nopin="nopin" /></p>

<p><strong>Representing the directed graph D:</strong></p>

<p><img src="/cs-notes/assets/images/algs/directed_2.png" nopin="nopin" /></p>

<p><strong>Implementing adjaceny lists:</strong><br />
   Define classes representing</p>

<ul>
  <li>an entry of adjacency lists</li>
  <li>a vertex (with a linked list representing its adjacency list)</li>
  <li>a graph (with a size and an array of vertices)</li>
</ul>

<p>Java <a href="#adjacency_list">implementation</a> of an adjacency list</p>

<p><a name="graph_search_topic"></a></p>

<h5 id="graph-searching-and-traversal-algorithms">Graph searching and traversal algorithms</h5>

<p>Graph traversal is efficient if it visits all vertices of the graph in <code class="highlighter-rouge">O( |V| + |E| )</code> time (by travelling along edges)</p>

<p><strong>Depth-first search:</strong></p>

<ul>
  <li>follow a path of unvisited vertices until path can be extended no further</li>
  <li>backtrack until an unvisited vertex is reached</li>
  <li>repeat until there are no unvisited vertices (in all components of graph)</li>
  <li>edges used form a <strong>depth-first spanning tree</strong></li>
</ul>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>explicit stack</li>
  <li>containing vertices on the path to the current vertex</li>
  <li>popping corresponds to backtracking</li>
</ul>

<p><strong>DFS example:</strong></p>

<p><img src="/cs-notes/assets/images/algs/dfs_1.png" nopin="nopin" /></p>

<p>DFS <a href="#dfs">implementation</a></p>

<p><strong>DFS complexity:</strong></p>

<ul>
  <li>each vertex is visited ( <code class="highlighter-rouge">n</code> )</li>
  <li>each element in adj. list is processed ( <code class="highlighter-rouge">m</code> )</li>
  <li>O(n + m)</li>
  <li>can adapt to adj. matrix representation, but this increases complexity to O(n<sup>2</sup>)</li>
</ul>

<p><strong>Applications of DFS:</strong></p>

<ul>
  <li>determine if graph is connected and/or identify its connected components</li>
  <li>determine if a graph is bipartite</li>
  <li>determine if a graph contains a cycle</li>
</ul>

<p><strong>Breadth-first search:</strong></p>

<ul>
  <li>visit all adjacent vertices of current vertex (processing)</li>
  <li>vertices processed in the order in which they are visited (queue)</li>
  <li>continue until all vertices in current component have been processed</li>
  <li>edges used form a <strong>breadth-first spanning tree</strong></li>
</ul>

<p><strong>Represent it as:</strong></p>

<ul>
  <li>queue</li>
  <li>visited vertices are added</li>
</ul>

<p><strong>BFS example:</strong></p>

<p><img src="/cs-notes/assets/images/algs/bfs_1.png" nopin="nopin" /></p>

<p>BFS <a href="#bfs">implementation</a></p>

<p><strong>BFS complexity:</strong></p>

<ul>
  <li>each vertex visited and queued exactly once</li>
  <li>each adj. list traversed once</li>
  <li>O(n + m)</li>
  <li>can adapt to adj. matrix as with DFS, but also O(n<sup>2</sup>)</li>
</ul>

<p><strong>Applications of BFS:</strong></p>

<ul>
  <li>finding distance between two vertices</li>
</ul>

<p><strong>Distance between two vertices:</strong></p>

<ul>
  <li>assign distance <code class="highlighter-rouge">v = 0</code></li>
  <li>carry out BFS from <code class="highlighter-rouge">v</code></li>
  <li>when visiting a new vertex
    <ul>
      <li>assign its distance to be <code class="highlighter-rouge">1 + distance to its predecessor</code></li>
    </ul>
  </li>
</ul>

<p><img src="/cs-notes/assets/images/algs/bfs_2.png" nopin="nopin" /></p>

<p><a name="graph_weight_topic"></a></p>

<h5 id="weighted-graphs">Weighted graphs</h5>

<p>Each edge <code class="highlighter-rouge">e</code> has an integer weight given by <code class="highlighter-rouge">wt( e ) &gt; 0</code> (undirected or directed)<br />
   Can represent weighted graphs using adj. lists and matrices as before</p>

<p><img src="/cs-notes/assets/images/algs/weighted_1.png" nopin="nopin" /></p>

<p><img src="/cs-notes/assets/images/algs/weighted_2.png" nopin="nopin" /></p>

<p><strong>Dijkstra’s algorithm:</strong></p>

<ul>
  <li>finds shortest path from one vertex <code class="highlighter-rouge">u</code> to all other vertices</li>
  <li>maintains a set containing all vertices for which shortest path from <code class="highlighter-rouge">u</code> is currently known</li>
  <li>each vertex <code class="highlighter-rouge">v</code> not in the set has a label <code class="highlighter-rouge">d(v)</code> = length of a shortest path from <code class="highlighter-rouge">u -&gt; v</code> passing <strong>only</strong> through vertices in the set</li>
  <li>after adding <code class="highlighter-rouge">v</code> to the set, carry out <strong>edge relaxation</strong> (updating distance <code class="highlighter-rouge">d(w)</code> for all vertices <code class="highlighter-rouge">w</code> still not in the set)</li>
</ul>

<p><strong>Edge relaxation:</strong></p>

<ul>
  <li>suppose <code class="highlighter-rouge">v</code> and <code class="highlighter-rouge">w</code> are not in <code class="highlighter-rouge">S</code>, then we know
    <ul>
      <li>the shortest path from <code class="highlighter-rouge">u -&gt; v</code> passing only through <code class="highlighter-rouge">S</code> is <code class="highlighter-rouge">d(v)</code></li>
      <li>the shortest path from <code class="highlighter-rouge">u -&gt; w</code> passing only through <code class="highlighter-rouge">S</code> is <code class="highlighter-rouge">d(w)</code></li>
    </ul>
  </li>
  <li>suppose <code class="highlighter-rouge">v</code> is added to <code class="highlighter-rouge">S</code> and the edge <code class="highlighter-rouge">e = { v,w }</code> has weight <code class="highlighter-rouge">wt( e )</code></li>
  <li>calculate the shortest path <code class="highlighter-rouge">u -&gt; w</code> passing only through <code class="highlighter-rouge">S ∪ { v }</code></li>
</ul>

<p><img src="/cs-notes/assets/images/algs/dijkstra_1.png" nopin="nopin" /></p>

<p>It is either:</p>

<ul>
  <li>the original path through <code class="highlighter-rouge">S</code> of length <code class="highlighter-rouge">d(w)</code></li>
  <li>the path combining edge <code class="highlighter-rouge">e</code> and shortest path <code class="highlighter-rouge">v -&gt; u</code> with length <code class="highlighter-rouge">wt( e ) + d(v)</code></li>
</ul>

<p>Therefore, the distance is: <br />
   <code class="highlighter-rouge">d(w) = min{ d(w), d(v) + wt( e ) }</code></p>

<p>Dijkstra’s algorithm <a href="#dijkstra">implementation</a></p>

<p><strong>Dijkstra complexity:</strong></p>

<ul>
  <li>with <code class="highlighter-rouge">n</code> vertices and <code class="highlighter-rouge">m</code> edges, using an <strong>unordered array</strong>
    <ul>
      <li>O(n) to initialise distances</li>
      <li>O(n<sup>2</sup>) to find minimum</li>
      <li>O(m) for relaxation</li>
    </ul>
  </li>
  <li>
    <p>hence, O(n<sup>2</sup>) overall</p>
  </li>
  <li>with <code class="highlighter-rouge">n</code> vertices and <code class="highlighter-rouge">m</code> edges, using a <strong>heap</strong>
    <ul>
      <li>O(n) to initialise distances and create heap</li>
      <li>O(n log n) to find minimum</li>
      <li>O(m log n) for relaxation</li>
    </ul>
  </li>
  <li>hence, O(m log n) overall (more edges than vertices)</li>
</ul>

<p><strong>Dijkstra example:</strong></p>

<p><img src="/cs-notes/assets/images/algs/dijkstra_2.png" nopin="nopin" /></p>

<p><strong>Spanning tree:</strong></p>

<ul>
  <li>subgraph which is both a tree and spans every vertex</li>
  <li>obtained from a connected graph by <strong>deleting edges</strong></li>
  <li>its weight = sum of weights of its edges</li>
</ul>

<p>For a weighted connected undirected graph, find a <strong>minimum weight spanning tree</strong> (represents the cheapest way of interconnecting the vertices)</p>

<p><img src="/cs-notes/assets/images/algs/spanning_tree.png" nopin="nopin" /></p>

<p><strong>Minimum weight spanning tree problem:</strong></p>

<p>This is an example of a <strong>greedy</strong> algorithm</p>

<ul>
  <li>makes a sequence of decisions based on <strong>local optimality</strong></li>
  <li>ends up with the <strong>globally optimal</strong> solution</li>
</ul>

<p><strong>Prim-Jarnik algorithm:</strong></p>

<ul>
  <li>minimum spanning tree contructed by choosing a sequence of edges</li>
  <li>initialisation is O(n) (where <code class="highlighter-rouge">n</code> is number of vertices)</li>
  <li>outer loop executed <code class="highlighter-rouge">n - 1</code> times</li>
  <li>inner loop checks all edges from a tree-vertex to a non-tree vertex, of which there can be O(n<sup>2</sup>)</li>
  <li>overall, alg. is O(n<sup>3</sup>)</li>
</ul>

<p>Prim-Jarnik algorithm <a href="#prim_jarnik">pseudocode</a></p>

<p>Prim-Jarnik example</p>

<p><img src="/cs-notes/assets/images/algs/prim_jarnik.png" nopin="nopin" /></p>

<p>The Prim-Jarnik proof of correctness will <strong>not</strong> be part of the exam, so it is omitted here.</p>

<p><strong>Dijkstra’s refinement:</strong></p>

<p>Introduce attribute <code class="highlighter-rouge">bestTV</code> for each non-tree vertex <code class="highlighter-rouge">q</code><br />
   This is the best tree vertex <code class="highlighter-rouge">p</code> for which <code class="highlighter-rouge">wt( {p, q} )</code> is minimised<br />
   <a href="#dijkstra_refinement">Pseudocode</a> for this concept</p>

<ul>
  <li>initialisation is O(n)</li>
  <li>while loop executed <code class="highlighter-rouge">n - 1</code> time</li>
  <li>O(n) to find minimal ntv</li>
  <li>O(1) to adjoin and update</li>
  <li>overall alg. is O(n<sup>2</sup>)</li>
</ul>

<p><a name="topological_topic"></a></p>

<h5 id="topological-ordering">Topological ordering</h5>

<p><strong>Directed Acyclic Graphs:</strong></p>

<p>A <strong>topological order</strong> on a DAG is a labelling of the vertices <code class="highlighter-rouge">1, ..., n</code> such that <code class="highlighter-rouge">(u, v) Î E</code> implies <code class="highlighter-rouge">label(u) &lt; label(v)</code><br />
   A directed graph D has a topological order if and only if D is a DAG<br />
   A <strong>source</strong> is a vertex of in-degree 0 and a <strong>sink</strong> has out-degree 0<br />
   <strong>A DAG has at least one souce and at least one sink</strong>, which forms the basis of a topological ordering alg.</p>

<p>Topological ordering of DAG <code class="highlighter-rouge">D</code>:</p>

<p><img src="/cs-notes/assets/images/algs/dag.png" nopin="nopin" /></p>

<p>Topological ordering alg. <a href="#topological_ordering">implementation</a></p>

<p><strong>TOA correctness:</strong></p>

<p>A vertex is given a label only when the number of incoming edges from unlabelled vertices is 0<br />
   For <code class="highlighter-rouge">n</code> vertices, <code class="highlighter-rouge">m</code> edges:</p>

<p>Adj. matrix representation involves</p>

<ul>
  <li>finding in-degree of each vertex, by scanning each column - O(n<sup>2</sup>)</li>
  <li>main loop executed <code class="highlighter-rouge">n</code> times for each row - O(n)</li>
  <li>overall alg. is O(n<sup>2</sup>)</li>
</ul>

<p>Adj. list representation involves</p>

<ul>
  <li>finding in-degree of each vertex, by scanning the list - O(n + m)</li>
  <li>main loop executed <code class="highlighter-rouge">n</code> times for each list</li>
  <li>overall alg. is O(n + m)</li>
</ul>

<p><strong>Deadlock detection:</strong></p>

<p>Methods to detect whether a digraph contains a cycle</p>

<ol>
  <li>adaptation of topological ordering alg.
    <ul>
      <li>if source list becomes empty before all vertices are labelled, there must be a cycle</li>
      <li>if all vertices can be labelled, the digraph is acyclic</li>
    </ul>
  </li>
  <li>adaptation of DFS
    <ul>
      <li>when a vertex is visited, check where there is an edge from it to another vertex which is on the current path from the current starting vertex</li>
      <li>the existence of such a vertex indicates a cycle</li>
    </ul>
  </li>
</ol>

<p><a name="section_5"></a></p>

<h4 id="np-completeness">NP Completeness</h4>

<ul>
  <li><a href="#np_intro_topic">Introduction</a></li>
  <li><a href="#np_complete_topic">NP-complete problems</a></li>
  <li><a href="#classes_topic">The classes P and NP</a></li>
  <li><a href="#poly_time_topic">Polynomial-time reductions</a></li>
  <li><a href="#np_def_topic">Formal def. of NP-completeness</a></li>
  <li><a href="#prove_np_topic">How to prove a problem is NP-complete</a></li>
</ul>

<p><a name="np_intro_topic"></a></p>

<h5 id="introduction-1">Introduction</h5>

<p>We have seen algorithms for a wide range of problems, all of which are polynomial-time: their worst cast complexity is O(n<sup>c</sup>) for some constant <code class="highlighter-rouge">c</code></p>

<p>Recall the Eulerian cycle problem: whether a graph has a cycle that traverses each <strong>edge</strong> exactly once<br />
   Theorem: A connected undirected graph has an Eulerian cycle if and only if each vertex has even degree<br />
   Therefore we can test and find such a cycle in a graph <code class="highlighter-rouge">G</code> in</p>

<ul>
  <li>O(n<sup>2</sup>) time if <code class="highlighter-rouge">G</code> is represented with an adj. matrix</li>
  <li>O(m + n) if it is represented with an adj. list (<code class="highlighter-rouge">m = |E|</code> and <code class="highlighter-rouge">n = |V|</code>)</li>
</ul>

<p>Recall the Hamiltonian cycle problem: whether a graph has a cycle that traverses each <strong>vertex</strong> exactly once<br />
   It is similar to the Eulerian cycle problem, but a polynomial-time algorithm has <strong>not</strong> been found to solve it<br />
   Its complexity is O(n<sup>2</sup> * n!) in the worst case<br />
   No polynomial-time algorithm has been found to solve this<br />
   Therefore this problem is <strong>NP-complete</strong></p>

<ul>
  <li>this is exponential (no better than O(b<sup>n</sup>) for some <code class="highlighter-rouge">b</code>)</li>
  <li>and cannot be expressed as O(n<sup>c</sup>)</li>
</ul>

<p><strong>Polynomial vs exponential:</strong></p>

<p><img src="/cs-notes/assets/images/algs/poly_vs_exp.png" nopin="nopin" /></p>

<p>Similar behaviour emerges in terms of computing power<br />
   Basically, a thousand-fold increase in computing power would only add <code class="highlighter-rouge">6</code> to the size of the largest problem instance solvable in <code class="highlighter-rouge">1</code> hour, for an algorithm of 3<sup>n</sup> complexity</p>

<p>A problem is <strong>polynomial-time solvable</strong> if it admits a polynomial-time algorithm</p>

<p><a name="np_complete_topic"></a></p>

<h5 id="np-completeness-1">NP-completeness</h5>

<p>No polynomial-time algorithm is known for an NP-complete problem<br />
   <strong>However</strong>, if one of them is solvable, then they all are</p>

<p>No proof of intractability is known for an NP-complete problem<br />
   <strong>However</strong>, if one of them is intractable, then they all are</p>

<p><strong>Causes of intractability:</strong></p>

<ol>
  <li>polynomial time is not sufficient in order to discover a solution
    <ul>
      <li>there are intractability proofs for this</li>
      <li>some problems are <strong>undecidable</strong> (no alg. could solve them)</li>
      <li>some decidable problems have been shown to be intractable</li>
    </ul>
  </li>
  <li>solution itself is so large that exp. time is needed to output it
    <ul>
      <li>eg problems of generating all cycles for a given graph</li>
    </ul>
  </li>
</ol>

<p><strong>Roadblock:</strong></p>

<ul>
  <li>two players A and B</li>
  <li>network of roads, with intersections</li>
  <li>each road is coloured black, blue or green</li>
  <li>some intersections are marked “A wins” or “B wins”</li>
  <li>a player has a fleet of cars located at intersections (one car per intersection)</li>
</ul>

<p>Player A begins, and then they take turns to</p>

<ul>
  <li>move a car of theirs on one or more roads of the same colour</li>
  <li>a car may not overlap an intersection which already has a car</li>
</ul>

<p>The problem is deciding, for a given starting configuration, whether A can win, regardless of what moves B takes</p>

<p><img src="/cs-notes/assets/images/algs/roadblock.png" nopin="nopin" /></p>

<p>So, <code class="highlighter-rouge">NP-complete problems</code> must be <strong>equal</strong> to one of: <code class="highlighter-rouge">Polynomial-time solvable problems</code> or <code class="highlighter-rouge">Intractable problems</code>, and <strong>not equal</strong> to the other</p>

<p><strong>Problems:</strong></p>

<p>A problem is characterised by unspecified parameters<br />
   A problem instance is created by giving these parameters values<br />
   An example of a decision problem is the Hamiltonian cycle:</p>

<ul>
  <li>the answer is a “yes” or “no”</li>
  <li>its instance if a graph <code class="highlighter-rouge">G</code></li>
  <li>every instance is either a “yes”-instance or a “no”-instance</li>
</ul>

<p><strong>Other NP-complete problems:</strong></p>

<p>Travelling Salesman Decision Problem<br />
   Instance: a set of <code class="highlighter-rouge">n</code> cities and integer distance <code class="highlighter-rouge">d(i, j)</code> between each pair of cities <code class="highlighter-rouge">i, j</code> and a target integer <code class="highlighter-rouge">K</code><br />
   Question: is there a permutation <code class="highlighter-rouge">P1P2...Pn-1Pn</code> of <code class="highlighter-rouge">1, 2,..., n</code> such that <code class="highlighter-rouge">d(P1, P2) + d(P2, P3) + ... + d(Pn-1, Pn) + d(Pn, P1) &lt;= K</code>?</p>

<p>Clique Problem<br />
   Instance: a graph <code class="highlighter-rouge">G</code> and target integer <code class="highlighter-rouge">K</code><br />
   Question: does <code class="highlighter-rouge">G</code> contain a clique of size <code class="highlighter-rouge">K</code>? (a set of <code class="highlighter-rouge">K</code> verices for which there is an edge between all pairs</p>

<p>Graph Colouring Problem<br />
   Instance: a graph <code class="highlighter-rouge">G</code> and target integer <code class="highlighter-rouge">K</code><br />
   Question: can one of <code class="highlighter-rouge">K</code> colours be attached to each vertex of <code class="highlighter-rouge">G</code> so that adjacent vertices always have different colours?</p>

<p><img src="/cs-notes/assets/images/algs/graph_colouring.png" nopin="nopin" /></p>

<p>Satisfiability<br />
   Instance: boolean expression <code class="highlighter-rouge">B</code> in <strong>conjunctive normal form</strong><br />
   CNF: <code class="highlighter-rouge">C1 ∧ C2 ∧ ... ∧ Cn</code> where each <code class="highlighter-rouge">Ci</code> is a <strong>clause</strong><br />
   Clause <code class="highlighter-rouge">C</code>: <code class="highlighter-rouge">L1 ∨ L2 ∨ ... ∨ Lm</code> where each <code class="highlighter-rouge">Lj</code> is a <strong>literal</strong><br />
   Literal <code class="highlighter-rouge">L</code>: a variable <code class="highlighter-rouge">x</code> or its negation <code class="highlighter-rouge">¬x</code><br />
   Question: is <code class="highlighter-rouge">B</code> satisfiable? (can values be assigned to the variables that make <code class="highlighter-rouge">B</code> true?)</p>

<p><img src="/cs-notes/assets/images/algs/satisfiability.png" nopin="nopin" /></p>

<p>NP-completeness deals primarily with decision problems</p>

<ul>
  <li>corresponding to each instance of an optimisation or search problem</li>
  <li>there is a family of instances of a decision problem obtainable by setting “target” values</li>
  <li>an optimisation or search problem can be solved in poly. time if and only if the corresponding decision problem can</li>
</ul>

<p><a name="classes_topic"></a></p>

<h5 id="the-classes-p-and-np">The classes P and NP</h5>

<p><strong>P:</strong></p>

<ul>
  <li>the class of all decision problems that can be solved in poly. time</li>
  <li>often extended to include search and optimisation problems</li>
</ul>

<p><strong>NP:</strong></p>

<ul>
  <li>the class of decision problems solvable in <strong>non-deterministic</strong> polynomial time (a non-deterministic alg. can make non-deterministic choices, and hence is more powerful than a deterministic alg.)</li>
  <li>P is contained within NP</li>
  <li>there is no problem known to be in NP and known not to be in P</li>
</ul>

<p><strong>P vs NP:</strong></p>

<p>A decision problem is NP if every “yes”-instance has a <strong>short certificate</strong><br />
   i.e. a structure that can be used to verify, in polynomial time, that it is a “yes”-instance<br />
   No corresponding claim is made for “no”-instances</p>

<p>It is immediate that <code class="highlighter-rouge">P ⊆ NP</code>, but whether <code class="highlighter-rouge">P = NP</code> or <code class="highlighter-rouge">P ⊂ NP</code> is unknown<br />
   Most believe that <code class="highlighter-rouge">P ≠ NP</code><br />
   But if so, there are problems that must lie in NP and not in P, and these are the NP-complete problems (the hardest, eg HC, TSDP, Graph Colouring etc)<br />
   A poly. time alg. for any of these would imply that they are <strong>all</strong> in P</p>

<p><strong>Non-deterministic algorithms:</strong></p>

<ul>
  <li>has an extra operation: non-deterministic choice</li>
  <li>has many possible executions depending on values returned from the choice</li>
  <li>it solves a decision problem <code class="highlighter-rouge">Π</code> if
    <ul>
      <li>for a “yes”-instance <code class="highlighter-rouge">I</code> of <code class="highlighter-rouge">Π</code> there is <strong>some</strong> execution that returns “yes”</li>
      <li>for a “no”-instance <code class="highlighter-rouge">I</code> of <code class="highlighter-rouge">Π</code> there is <strong>no</strong> execution that returns “yes”</li>
    </ul>
  </li>
  <li>and solves a decision problem <code class="highlighter-rouge">Π</code> in poly. time if
    <ul>
      <li>for every “yes”-instance <code class="highlighter-rouge">I</code> of <code class="highlighter-rouge">Π</code> there is <strong>some</strong> execution <code class="highlighter-rouge">E</code> that returns “yes”, which uses a number of steps bounded by a polynomial in the input</li>
    </ul>
  </li>
</ul>

<p>A non-deterministic alg. can be viewed as</p>

<ul>
  <li>a guessing stage (non-deterministic)</li>
  <li>a checking stage (deterministic and poly. time)</li>
</ul>

<p>Start —&gt; guess a “certificate” —&gt; verify the certificate —&gt; Stop</p>

<p><a href="#non_deterministic">Example</a> of a non-deterministic alg.</p>

<p><a name="poly_time_topic"></a></p>

<h5 id="polynomial-time-reductions">Polynomial-time reductions</h5>

<p>A mapping <code class="highlighter-rouge">f</code> from a decision problem <code class="highlighter-rouge">Π1</code> to a decision problem <code class="highlighter-rouge">Π2</code> such that</p>

<ul>
  <li>for every instance <code class="highlighter-rouge">I1</code> of <code class="highlighter-rouge">Π1</code> we have
    <ul>
      <li>the instance <code class="highlighter-rouge">f(I1)</code> of <code class="highlighter-rouge">Π2</code> can be contructed in poly. time</li>
      <li><code class="highlighter-rouge">f(I1)</code> is a “yes”-instance of <code class="highlighter-rouge">Π2</code> if and only if <code class="highlighter-rouge">I1</code> is a “yes”-instance of <code class="highlighter-rouge">Π1</code></li>
    </ul>
  </li>
  <li>we write <code class="highlighter-rouge">Π1 ∝ Π2</code> as an abbreviation for: there is a polynomial-time reduction from <code class="highlighter-rouge">Π1</code> to <code class="highlighter-rouge">Π2</code></li>
</ul>

<p><strong>Properties of polynomial-time reductions:</strong></p>

<p>Transitivity: <code class="highlighter-rouge">Π1 ∝ Π2</code> and <code class="highlighter-rouge">Π2 ∝ Π3</code> implies that <code class="highlighter-rouge">Π1 ∝ Π3</code></p>

<p>Since <code class="highlighter-rouge">Π1 ∝ Π2</code> and <code class="highlighter-rouge">Π2 ∝ Π3</code> we have</p>

<ul>
  <li>a PTR <code class="highlighter-rouge">f</code> from <code class="highlighter-rouge">Π1</code> to <code class="highlighter-rouge">Π2</code></li>
  <li>a PTR <code class="highlighter-rouge">g</code> from <code class="highlighter-rouge">Π2</code> to <code class="highlighter-rouge">Π3</code></li>
</ul>

<p>For any instance <code class="highlighter-rouge">I1</code> of <code class="highlighter-rouge">Π1</code>, since <code class="highlighter-rouge">f</code> is a PTR, we have</p>

<ul>
  <li><code class="highlighter-rouge">I2 = f( I1 )</code> is an instance of <code class="highlighter-rouge">Π2</code> that can be constructed in poly. time</li>
  <li><code class="highlighter-rouge">I2</code> has the same answer as <code class="highlighter-rouge">I1</code></li>
</ul>

<p>Since <code class="highlighter-rouge">g</code> is a PTR, we have</p>

<ul>
  <li><code class="highlighter-rouge">I3 = g( I2 )</code> is an instance of <code class="highlighter-rouge">Π3</code> that can be constructed in poly. time</li>
  <li><code class="highlighter-rouge">I3</code> has the same answer as <code class="highlighter-rouge">I2</code></li>
</ul>

<p>Putting the results together, for any instance <code class="highlighter-rouge">I1</code> of <code class="highlighter-rouge">Π1</code></p>

<ul>
  <li><code class="highlighter-rouge">I3 = g( f( I1 ) )</code> is an instance of <code class="highlighter-rouge">Π3</code> constructed in poly. time</li>
  <li><code class="highlighter-rouge">I3</code> has the same answer as <code class="highlighter-rouge">I1</code></li>
  <li>ie the composition of <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code> is a PTR from <code class="highlighter-rouge">Π1</code> to <code class="highlighter-rouge">Π3</code></li>
</ul>

<p><code class="highlighter-rouge">Π1 ∝ Π2</code> and <code class="highlighter-rouge">Π2 Î P</code> implies that <code class="highlighter-rouge">Π1 Î P</code></p>

<ul>
  <li>to solve an instance of <code class="highlighter-rouge">Π1</code>, reduce it to an instance of <code class="highlighter-rouge">Π2</code></li>
  <li><code class="highlighter-rouge">Π1 ∝ Π2</code> means that <code class="highlighter-rouge">Π1</code> is no harder than <code class="highlighter-rouge">Π2</code></li>
  <li>i.e. if we can solve <code class="highlighter-rouge">Π2</code>, then we can solve <code class="highlighter-rouge">Π1</code> without much more effort</li>
</ul>

<p>For example, reducing the Hamiltonian cycle problem to the travelling salesman problem:<br />
   HC instance: a graph G<br />
   HC question: does G contain a cycle that visits each vertex exactly once?</p>

<p>TSDP instance: a set of <code class="highlighter-rouge">n</code> cities and integer distance <code class="highlighter-rouge">d(i, j)</code> between each pair of cities <code class="highlighter-rouge">i, j</code> and a target integer <code class="highlighter-rouge">K</code><br />
   TSDP question: is there a permutation <code class="highlighter-rouge">p</code> of <code class="highlighter-rouge"><span class="p">{</span><span class="err">1,</span><span class="w"> </span><span class="err">2,...,</span><span class="w"> </span><span class="err">n</span><span class="p">}</span></code> such that <code class="highlighter-rouge">d(P1, P2) + d(P2, P3) + ... + d(Pn-1, Pn) + d(Pn, P1) &lt;= K</code>?</p>

<ul>
  <li><code class="highlighter-rouge">G = (V, E)</code> is an instance of HC</li>
  <li>construct TSP <code class="highlighter-rouge">f(G)</code> where
    <ul>
      <li>cities = <code class="highlighter-rouge">V</code></li>
      <li><code class="highlighter-rouge">d(u, v) = 1</code> if <code class="highlighter-rouge"><span class="p">{</span><span class="err">u,</span><span class="w"> </span><span class="err">v</span><span class="p">}</span><span class="w"> </span><span class="err">Î</span><span class="w"> </span><span class="err">E</span></code> and <code class="highlighter-rouge">0</code> otherwise</li>
      <li><code class="highlighter-rouge">K = |V|</code></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">f(G)</code> can be constructed in poly. time</li>
  <li><code class="highlighter-rouge">f(G)</code> has a tour of length <code class="highlighter-rouge">&lt;= |V|</code> if and only if <code class="highlighter-rouge">G</code> has a Hamiltonian cycle (cannot take any of the edges with weight 2)</li>
  <li>therefore <code class="highlighter-rouge">TSDP Î P</code> implies that <code class="highlighter-rouge">HC Î P</code></li>
  <li>equivalently <code class="highlighter-rouge">HC Ï P</code>implies that <code class="highlighter-rouge">TSDP Ï P</code></li>
</ul>

<p><img src="/cs-notes/assets/images/algs/hc_to_tsdp.png" nopin="nopin" /></p>

<p><a name="np_def_topic"></a></p>

<h5 id="definition">Definition</h5>

<p>A decision problem <code class="highlighter-rouge">Π</code> is NP-complete if</p>

<ul>
  <li><code class="highlighter-rouge">Π Î NP</code></li>
  <li><code class="highlighter-rouge">Π’</code> is polynomial-time reducable to <code class="highlighter-rouge">Π</code> (<code class="highlighter-rouge">Π’∝Π</code> for every problem <code class="highlighter-rouge">Π’</code> in NP)</li>
</ul>

<p>So if <code class="highlighter-rouge">Π</code> is NP-complete and <code class="highlighter-rouge">Π Î P</code> then P = NP<br />
   Every problem in NP can be solved in polynomial time by reduction to <code class="highlighter-rouge">Π</code><br />
   Supposing P ≠ NP, if <code class="highlighter-rouge">Π</code> is NP-complete, then <code class="highlighter-rouge">Π Ï P</code></p>

<p><img src="/cs-notes/assets/images/algs/np_structure.png" nopin="nopin" /></p>

<p><a name="prove_np_topic"></a></p>

<h5 id="proving-np-completeness">Proving NP-completeness</h5>

<p>It is not feasible to describe a reduction from <strong>every</strong> problem in NP<br />
   However, suppose we knew just one NP-complete problem <code class="highlighter-rouge">Π1</code></p>

<p>To prove <code class="highlighter-rouge">Π2</code> is NP-complete, it is enough to show</p>

<ul>
  <li><code class="highlighter-rouge">Π2</code> is in NP</li>
  <li>there exists a polynomial-time reduction from <code class="highlighter-rouge">Π1</code> to <code class="highlighter-rouge">Π2</code> (<code class="highlighter-rouge">Π1 ∝ Π2</code>)</li>
</ul>

<p>Correctness of the approach:</p>

<ul>
  <li>for any <code class="highlighter-rouge">Π' Î NP</code>, since <code class="highlighter-rouge">Π1</code> is NP-complete we have <code class="highlighter-rouge">Π' ∝ Π1</code></li>
  <li>since <code class="highlighter-rouge">Π' ∝ Π</code>, <code class="highlighter-rouge">Π1 ∝ Π2</code> and in is transitive, it follows that <code class="highlighter-rouge">Π' ∝ Π2</code></li>
  <li>since <code class="highlighter-rouge">Π' Î NP</code> was arbitrary, <code class="highlighter-rouge">Π' ∝ Π2</code> for all <code class="highlighter-rouge">Π' Î NP</code></li>
  <li>hence <code class="highlighter-rouge">Π2</code> is NP-complete</li>
</ul>

<p>Cook’s Theorem, where the Satisfiability (SAT) problem is NP-complete</p>

<ul>
  <li>proof consists of generic poly-time reduction to SAT from an abstract definition of a general problem in NP</li>
  <li>generic reduction could be instantiated to give an actual reduction for each individual NP problem</li>
  <li>given this theorem, to prove that problem P is NP-complete it is sufficient to show that
    <ul>
      <li><code class="highlighter-rouge">Π</code> is in NP</li>
      <li>there exists a poly-time reduction from SAT to <code class="highlighter-rouge">Π</code></li>
    </ul>
  </li>
</ul>

<p><strong>Clique Problem:</strong></p>

<p>Instance: graph G and target integer K<br />
   Question: does G contain a clique of size K?<br />
   Proving: show clique is in NP, and that there exists a poly-time reduction from SAT to <code class="highlighter-rouge">Π</code></p>

<p>We need to show SAT ∝ Clique:<br />
   Given an instance B of SAT we construct a <code class="highlighter-rouge">(G, K)</code> instance of Clique</p>

<ul>
  <li>K number of clauses of B</li>
  <li>vertices of G are pairs <code class="highlighter-rouge">(l, C)</code> where <code class="highlighter-rouge">l</code> is a literal clause of <code class="highlighter-rouge">C</code></li>
  <li><code class="highlighter-rouge"><span class="p">{</span><span class="err">(l,</span><span class="w"> </span><span class="err">C),</span><span class="w"> </span><span class="err">(m,</span><span class="w"> </span><span class="err">D)</span><span class="p">}</span></code> is an edge of G if and only if <code class="highlighter-rouge">l ≠ ¬m</code> and <code class="highlighter-rouge">C ≠ D</code>
    <ul>
      <li>edge if distinct literals from different clauses can be satisfied simultaneously</li>
    </ul>
  </li>
  <li>poly-time construction O(n<sup>2</sup>) (with <code class="highlighter-rouge">n</code> literals)</li>
  <li>this is a poly-time reduction since B has a satisfying argument if and only if G has a clique of size K</li>
</ul>

<p>Proving it is a poly-time reduction:</p>

<ul>
  <li>if B has a satisfying assignment then
    <ul>
      <li>if we choose a <strong>true</strong> literal in each clause the corresponding vertices form a clique of size K in G</li>
    </ul>
  </li>
  <li>if G has a clique of size K then
    <ul>
      <li>assigning each literal associated with a vertex in the clique to be true yields a satisfying assignment for B</li>
    </ul>
  </li>
</ul>

<p>The following graph G has a clique of size 4 if and only if B has a satisfying assignment (which is a clique of size 4 here)</p>

<p><img src="/cs-notes/assets/images/algs/clique.png" nopin="nopin" /></p>

<p><code class="highlighter-rouge">B = (x1 ∨ x2 ∨ ¬x3) ∧ (¬x1 ∨ x3 ∨ ¬x4) ∧ (¬x2 ∨ x4) ∧ (x2 ∨ ¬x3 ∨ x4)</code><br />
   There are K = 4 clauses (bracket pairs)</p>

<p><strong>Problem restrictions:</strong></p>

<p>A restriction consists of a subset of the instances of the original problem<br />
  If a restriction of a given decision problem <code class="highlighter-rouge">Π</code> is NP-complete, then so is <code class="highlighter-rouge">Π</code><br />
  Given NP-complete <code class="highlighter-rouge">Π</code>, a restriction of <code class="highlighter-rouge">Π</code> <strong>might</strong> be NP-complete</p>

<p>eg a clique restricted to cubic graphs is in P, so a largest clique has size at most 4, so exhaustive search is O(n<sup>4</sup>)</p>

<p>K-colouring:<br />
   Restriction of Graph Colouring for a fixed K number of colours<br />
   2-colouring is in P, while 3-colouring is NP-complete</p>

<p>K-SAT:<br />
   Restriction of SAT in which every clause contains exactly K literals<br />
   2-SAT is in P, while 3-SAT in NP-complete<br />
   Showing 3-SAT Î NP is easy</p>

<p><strong>SAT ∝ 3-SAT:</strong></p>

<p>Given instance B of SAT we will construct an instance B’ of 3-SAT<br />
   For each clause Ci of B we construct a number of clauses of B’</p>

<ul>
  <li>if <code class="highlighter-rouge">C = l1</code>
    <ul>
      <li>introduce 2 additional variables x1 and x2, and add the clauses <code class="highlighter-rouge">(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ ¬x2), (l1 ∨ ¬x1 ∨ x2), (l1 ∨ ¬x1 ∨ ¬x2)</code> to B’</li>
    </ul>
  </li>
  <li>if <code class="highlighter-rouge">C = (l1 ∨ l2)</code>
    <ul>
      <li>introduce 1 additional variable y and the clauses <code class="highlighter-rouge">(l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ ¬y)</code> to B’</li>
    </ul>
  </li>
  <li>if <code class="highlighter-rouge">C = (l1 ∨ l2 ∨ l3)</code>
    <ul>
      <li>add the clause C to B’</li>
    </ul>
  </li>
  <li>if <code class="highlighter-rouge">C = (l1 ∨ ... ∨ lk)</code> and <code class="highlighter-rouge">k &gt; 3</code>
    <ul>
      <li>introduce k - 3 additional variables z<sub>1</sub>, …, z<sub>k-3</sub></li>
      <li>add the clauses <code class="highlighter-rouge">(l1 ∨ l2 ∨ z1), (¬z1 ∨ l3 ∨ z2), (¬z2 ∨ l4 ∨ z3), ..., (¬zk-4 ∨ lk-2 ∨ zk-3), (¬zk-3 ∨ lk-1 ∨ lk)</code> to B’</li>
    </ul>
  </li>
</ul>

<p><strong>Coping with NP-completeness:</strong></p>

<p>Maybe only a restricted version is of interest (which may be in P)<br />
   Seek an exponential-time alg. which improves on exhaustive search<br />
   For an optimisation problem:</p>

<ul>
  <li>settle for an approximation alg. that runs in poly-time</li>
  <li>esp. if it gives a probably good result</li>
  <li>use a heuristic</li>
</ul>

<p>For a decision problem:</p>

<ul>
  <li>settle for a probabilistic alg. (correct answer with high probability)</li>
</ul>

<p><a name="section_6"></a></p>

<h4 id="computability">Computability</h4>

<ul>
  <li><a href="#computability_intro">Introduction</a></li>
  <li><a href="#halting_topic">The halting problem</a></li>
  <li><a href="#computation_models_topic">Models of computation</a></li>
</ul>

<p><a name="computability_intro"></a></p>

<h5 id="introduction-2">Introduction</h5>

<p>A computer is:</p>

<p><code class="highlighter-rouge">input x --&gt; BLACK BOX --&gt; output f(x)</code></p>

<p>The black box computes a function that maps an input to an output<br />
   What functions can be computed? Alternatively, what problems can be solved?<br />
   We need a definition of an algorithm if we view a computer as a device that can execute one</p>

<p>Some problems cannot be solved by a computer, eg the Tiling problem<br />
   A 1x1 square tile divided into 4 triangles by its diagonals with each triangle a given colour<br />
   Each tile has a fixed orientation and no rotations are allowed<br />
   Instance: a finite set <code class="highlighter-rouge">S</code> of tile descriptions<br />
   Question: can any finite area, of any size, be completely covered using only tiles of types in <code class="highlighter-rouge">S</code>, so that adjacent tile colours match?</p>

<p>For example, tiling a 5x5 square:</p>

<p><img src="/cs-notes/assets/images/algs/tiling_1.png" nopin="nopin" /></p>

<p>Or extending to a larger region:</p>

<ul>
  <li>overlap the top two rows with the bottom two rows (for an 8x5 tiled area)</li>
  <li>place two of these 8x5’s side by side (with the right hand rectangle one row above the left hand rectangle)</li>
  <li>and repeat this pattern to tile any finite area</li>
</ul>

<p><img src="/cs-notes/assets/images/algs/tiling_2.png" nopin="nopin" /></p>

<p>Tiling a 10x10 square:</p>

<p><img src="/cs-notes/assets/images/algs/tiling_3.png" nopin="nopin" /></p>

<p>There is <strong>no</strong> alg. for this problem<br />
   For any alg. A that we might formulate, there is a set of tiles <code class="highlighter-rouge">S</code> for which either A doesn’t terminate or gives the wrong answer<br />
   The problem is that:</p>

<ul>
  <li>“any size” means that we have to check all finite areas and there are infinitely many of these</li>
  <li>for certain sets of tile descriptions that can tile any area, there is no “repeated pattern” we can use</li>
  <li>would really have to be exhaustive</li>
</ul>

<p><strong>Undecidable problems:</strong></p>

<p>A problem <code class="highlighter-rouge">Π</code> that admits no alg. is called <strong>non-computable</strong> or <strong>unsolvable</strong><br />
   If <code class="highlighter-rouge">Π</code> is a decision problem and admits no alg., then it is called <strong>undecidable</strong> (tiling problem is one)</p>

<p><strong>Post’s correspondence problem:</strong></p>

<p>A word is a finite string over some given finite alphabet<br />
   Instance: two finite sequences of words <code class="highlighter-rouge">X1, ..., Xn</code> and <code class="highlighter-rouge">Y1, ..., Yn</code> (in the same alphabet)<br />
   Question: does there exist a sequence <code class="highlighter-rouge">i1, i2, ..., ir</code> of integers chosen from <code class="highlighter-rouge"><span class="p">{</span><span class="err">1,</span><span class="w"> </span><span class="err">...,</span><span class="w"> </span><span class="err">n</span><span class="p">}</span></code> such that <code class="highlighter-rouge">Xi1Xi2...Xir = Yi1Yi2...Yir</code>?</p>

<p>For <code class="highlighter-rouge">n = 5</code></p>

<ul>
  <li>X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba</li>
  <li>Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a</li>
  <li>correspondence given by sequence <code class="highlighter-rouge">2, 1, 1, 4, 1, 5</code>
    <ul>
      <li>word constructed from Xi’s = aabbabbbabaabbaba</li>
      <li>word constructed from Yi’s = aabbabbbabaabbaba</li>
    </ul>
  </li>
  <li>however, if we removed the first letter from X1 and Y1, then we could never get a correspondence</li>
  <li>thus this problem is undecidable</li>
</ul>

<p><a name="halting_topic"></a></p>

<h5 id="the-halting-problem">The halting problem</h5>

<p>Instance: a legal Java program <code class="highlighter-rouge">X</code> and an input string <code class="highlighter-rouge">S</code> for <code class="highlighter-rouge">X</code><br />
   Question: does <code class="highlighter-rouge">X</code> halt when run on <code class="highlighter-rouge">S</code>?<br />
   We will prove that no such program can exist, and that thus, the halting problem is undecidable</p>

<p>The below program <code class="highlighter-rouge">T</code> will terminate if and only if input <code class="highlighter-rouge">n ≠ 1</code></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">public</span> <span class="k">void</span> <span class="nx">t</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	  <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>With a word “erratic”, <code class="highlighter-rouge">T</code> is called with <code class="highlighter-rouge">n = 7</code> sequence of values:<br />
   <code class="highlighter-rouge">22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1</code><br />
   Then nobody knows whether “erratic” terminates for all values of <code class="highlighter-rouge">n</code></p>

<p><strong>Proof by contradiction that HP is undecidable:</strong></p>

<p>Suppose we have alg. <code class="highlighter-rouge">A</code> that solves HP<br />
   Let <code class="highlighter-rouge">Q</code> be an implementation of this alg. as a Java method with <code class="highlighter-rouge">X</code> and <code class="highlighter-rouge">S</code> parameters</p>

<p><img src="/cs-notes/assets/images/algs/halting_1.png" nopin="nopin" /></p>

<p>Define a new program <code class="highlighter-rouge">P</code> with a legal program <code class="highlighter-rouge">W</code> as input</p>

<p><img src="/cs-notes/assets/images/algs/halting_2.png" nopin="nopin" /></p>

<ul>
  <li><code class="highlighter-rouge">P</code> makes a copy of <code class="highlighter-rouge">W</code> and calls <code class="highlighter-rouge">Q(W, W)</code></li>
  <li><code class="highlighter-rouge">Q</code> terminates by assumption</li>
  <li>if it returns “yes”, <code class="highlighter-rouge">P</code> enters an infinite loop</li>
  <li>if it returns “no”, <code class="highlighter-rouge">P</code> is terminated</li>
</ul>

<p>Now let the input <code class="highlighter-rouge">W</code> to <code class="highlighter-rouge">P</code> be the program <code class="highlighter-rouge">P</code> itself<br />
   Then <code class="highlighter-rouge">P</code> would call <code class="highlighter-rouge">Q(P, P)</code> (recall we assumed that <code class="highlighter-rouge">Q</code> solves HP)</p>

<ul>
  <li>if <code class="highlighter-rouge">Q</code> returns “yes”, then by definition of <code class="highlighter-rouge">Q</code> this means <code class="highlighter-rouge">P</code> terminates</li>
  <li>but this also means <code class="highlighter-rouge">P</code> does not terminate (it enters into the loop)</li>
  <li>this is a contradiction, therefore <code class="highlighter-rouge">Q</code> must return “no”</li>
  <li>and this means by definition of <code class="highlighter-rouge">Q</code> that <code class="highlighter-rouge">P</code> does no terminate</li>
  <li>but it also means that <code class="highlighter-rouge">P</code> does terminate</li>
  <li>again, it is a contradiction</li>
  <li>so if it can return neither reply, no such <code class="highlighter-rouge">Q</code> can exist</li>
  <li>therefore no alg. can solve HP</li>
</ul>

<p><strong>Proving undecidabiltiy by reduction:</strong></p>

<p>Suppose we can reduce any instance <code class="highlighter-rouge">I</code> of <code class="highlighter-rouge">Π1</code> into an instance <code class="highlighter-rouge">J</code> of <code class="highlighter-rouge">Π2</code> such that <code class="highlighter-rouge">I</code> has a “yes” answer for <code class="highlighter-rouge">Π1</code> if and only if <code class="highlighter-rouge">J</code> has a “yes” answer for <code class="highlighter-rouge">Π2</code> (no need for <code class="highlighter-rouge">J</code> to be constructed in poly-time)<br />
   If <code class="highlighter-rouge">Π1</code> is undecidable and we can perform such a reduction, then <code class="highlighter-rouge">Π2</code> is undecidable</p>

<p><strong>Hierarchy of decision problems:</strong></p>

<p><img src="/cs-notes/assets/images/algs/decision_hierarchy.png" nopin="nopin" /></p>

<p><a name="computation_models_topic"></a></p>

<h5 id="models-of-computation">Models of computation</h5>

<p><strong>Deterministic finite-state automata (DFAs):</strong></p>

<ul>
  <li>simple machines with limited memory</li>
  <li>recognise input on a read-only tape</li>
</ul>

<p>Consists of:</p>

<ul>
  <li>a finite input alphabet <code class="highlighter-rouge">A</code></li>
  <li>a finite set of states <code class="highlighter-rouge">Q</code></li>
  <li>an initial state <code class="highlighter-rouge">q0 ∈ Q</code> and set of <strong>accepting</strong> states <code class="highlighter-rouge">F ⊆ Q</code></li>
  <li>control/program or <strong>transition relation</strong> <code class="highlighter-rouge">T ⊆ (Q * A) * Q</code>
    <ul>
      <li><code class="highlighter-rouge">((q, a), q') ∈ T</code> means if in state <code class="highlighter-rouge">q</code> and read <code class="highlighter-rouge">a</code>, then move to state <code class="highlighter-rouge">q'</code></li>
    </ul>
  </li>
  <li>deterministic means that if <code class="highlighter-rouge">((q, a1), q1), ((q, a2), q2) ∈ T</code> either <code class="highlighter-rouge">a1 ≠ a2</code> or <code class="highlighter-rouge">q1 = q2</code>
    <ul>
      <li>for any state and action there is at most one move</li>
    </ul>
  </li>
</ul>

<p><img src="/cs-notes/assets/images/algs/dfa_1.png" nopin="nopin" /></p>

<ul>
  <li>initial state denoted by incoming arrow</li>
  <li>accepting states denoted by double circles</li>
</ul>

<p>Control/program for the above example:</p>

<p><img src="/cs-notes/assets/images/algs/dfa_control.png" nopin="nopin" /></p>

<p>A DFA defines a language</p>

<ul>
  <li>determines whether the string on the input tape belongs to that lang.</li>
  <li>ie solves a decision problem</li>
  <li>it <strong>accepts</strong> a lang., through the input strings which, when “run”, end in an accepting state</li>
  <li>in the above example, the DFA accepts the lang. consisting of the set of all strings comprising one or more a’s followed by one or more b’s (and its complement ie the language of strings with no consecutive a’s)</li>
</ul>

<p><strong>Non-deteministic finite-state automation (NFA):</strong></p>

<p><img src="/cs-notes/assets/images/algs/dfa_2.png" nopin="nopin" /></p>

<p>This one recognises strings that start and end with a <code class="highlighter-rouge">b</code> (in state <code class="highlighter-rouge">q1</code> the <code class="highlighter-rouge">b</code> underneath can move to <code class="highlighter-rouge">q1</code> or <code class="highlighter-rouge">q2</code>)</p>

<p>Recognition for NFA is similar to non-deterministics algs. solving a decision problem</p>

<ul>
  <li>only require there exists a “run” that ends in an accepting state</li>
  <li>any NFA can be converted to a DFA</li>
  <li>therefore non-determinism doesn’t expand the class of languages that can be recognised by finite state automata</li>
</ul>

<p><strong>NFA to DFA reduction:</strong></p>

<ul>
  <li>use the subset construction
    <ul>
      <li>states of DFA are sets of states of the NFA</li>
      <li>construction can cause a blow-up in number of states</li>
    </ul>
  </li>
</ul>

<p>Example without blow-up (recognises strings that start and end with <code class="highlighter-rouge">b</code>):</p>

<p><img src="/cs-notes/assets/images/algs/nfa_to_dfa.png" nopin="nopin" /></p>

<p><strong>Regular languages:</strong></p>

<p>Languages that can be recognised by finite state automata<br />
   A reg. lang. over an alphabet <code class="highlighter-rouge">A</code> can be specified by a <strong>regular expression</strong> over <code class="highlighter-rouge">A</code><br />
   <code class="highlighter-rouge">ε</code> and <code class="highlighter-rouge">σ</code> are regex’s</p>

<p><strong>Regular expressions:</strong></p>

<p>If <code class="highlighter-rouge">R</code> and <code class="highlighter-rouge">S</code> are regex’s then so are (in order of lowest precedence first):</p>

<ul>
  <li><code class="highlighter-rouge">R | S</code> which denotes choice</li>
  <li><code class="highlighter-rouge">RS</code> which denotes concatenation</li>
  <li><code class="highlighter-rouge">R*</code> which denotes 0 or more copies or <code class="highlighter-rouge">R</code> (closure)</li>
  <li><code class="highlighter-rouge">(R)</code> which is needed to override operator precedence</li>
</ul>

<p>Additional operations:</p>

<ul>
  <li>complement <code class="highlighter-rouge">¬x</code> (equivalent to the “or” of all chars. in <code class="highlighter-rouge">A</code> except <code class="highlighter-rouge">x</code>)</li>
  <li>any single char. <code class="highlighter-rouge">?</code> (equivalent to the “or” of all chars.)</li>
</ul>

<p>Examples:</p>

<ol>
  <li>the lang. comprising 1+ a’s followed by 1+ b’s
    <ul>
      <li><code class="highlighter-rouge">aa*bb*</code></li>
    </ul>
  </li>
  <li>the lang. of string containing 2 consecutive a’s
    <ul>
      <li><code class="highlighter-rouge">(a* | b*)* a a (a* | b*)*</code></li>
    </ul>
  </li>
  <li>the lang of strings that don’t contain 2 consecutive a’s
    <ul>
      <li><code class="highlighter-rouge">b* (abb*)* (ε | a)</code></li>
    </ul>
  </li>
  <li>the lang. of strings that start and end with <code class="highlighter-rouge">b</code>
    <ul>
      <li><code class="highlighter-rouge">b (a* | b*)* b</code></li>
    </ul>
  </li>
</ol>

<p><strong>Note:</strong> <code class="highlighter-rouge">L(R*)</code> does not mean <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">r*</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="err">r</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="err">L(R)</span><span class="w"> </span><span class="p">}</span></code></p>

<ul>
  <li>for certain regex’s, this cannot be recognised by any DFA</li>
  <li>for such a lang., would need a memory to remember which string in <code class="highlighter-rouge">r ∈ L(R)</code> is repeated
    <ul>
      <li>might be an unbounded number</li>
    </ul>
  </li>
</ul>

<p>Regex example:</p>

<p>Consider lang. <code class="highlighter-rouge">(aa*bb*)*</code> with DFA</p>

<p><img src="/cs-notes/assets/images/algs/regex_dfa.png" nopin="nopin" /></p>

<p>A DFA can’t recognise <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">r*</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="err">r</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="err">L(aa*bb*)</span><span class="w"> </span><span class="p">}</span></code></p>

<ul>
  <li>ie { (a<sup>m</sup>b<sup>n</sup>)<code class="highlighter-rouge">* |</code> m &gt; 0 and n &gt; 0 }</li>
  <li>would need to remember the <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> to check that a string is in the lang.</li>
  <li>infinitely many values for <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code></li>
  <li>so it would need infintely many states</li>
  <li>so, this is not a regular language</li>
  <li>similarly, it can’t recognise { (a<sup>n</sup>b<sup>n</sup>)<code class="highlighter-rouge">* |</code> n &gt; 0 }
    <ul>
      <li>might need to use a stack, where a’s are pushed as they are read, and popped as b’s are read (like a counter)</li>
    </ul>
  </li>
</ul>

<p><strong>Pushdown automata:</strong></p>

<ul>
  <li>unlimited memory</li>
  <li>behave like a stack</li>
</ul>

<p>Consists of:</p>

<ul>
  <li>finite input alphabet <code class="highlighter-rouge">A</code></li>
  <li>finite set of stack symbols <code class="highlighter-rouge">G</code></li>
  <li>finite set of states <code class="highlighter-rouge">Q</code> including start state and set of accepting states</li>
  <li>control/transition relation <code class="highlighter-rouge">T ⊆ (Q * AÈ{ε} * GÈ{ε}) * (Q * GÈ{ε})</code></li>
</ul>

<p><img src="/cs-notes/assets/images/algs/pushdown_1.png" nopin="nopin" /></p>

<p>Informally, the transition <code class="highlighter-rouge">(q, a, w) --&gt; (r, v)</code> means that</p>

<ul>
  <li>if we are in state <code class="highlighter-rouge">q</code></li>
  <li>if <code class="highlighter-rouge">a ≠ ε</code> then <code class="highlighter-rouge">a</code> is at head of tape</li>
  <li>if <code class="highlighter-rouge">w ≠ ε</code> then <code class="highlighter-rouge">w</code> is at top of stack</li>
  <li>move to state <code class="highlighter-rouge">r</code> and
    <ul>
      <li>if <code class="highlighter-rouge">a ≠ ε</code> then head++</li>
      <li>if <code class="highlighter-rouge">w ≠ ε</code> then pop <code class="highlighter-rouge">w</code> from stack</li>
      <li>if <code class="highlighter-rouge">v ≠ ε</code> then push <code class="highlighter-rouge">v</code> onto stack</li>
    </ul>
  </li>
</ul>

<p>A PDA accepts an input if and only if after the input has been read, the stack is empty and control is in an accepting state<br />
   There is no explicit test for empty stack, but you can just add a <code class="highlighter-rouge">$</code> symbol to the stack at start of computation<br />
   Then check for emptiness when this symbol is at top of stack</p>

<p>The PDA defined here are non-deterministic (NDPDA)<br />
   More powerful than deterministic PDAs<br />
   ie it can recognise languages that the DPDA might not, such as palindromes</p>

<p><strong>Palindromes:</strong></p>

<p>Sequences of chars. that read the same backwards as forwards<br />
   Recognising with a PDA:</p>

<ul>
  <li>push first half of sequence onto stack</li>
  <li>as you read each char., check that it’s the same as the top of the stack and pop that element</li>
  <li>enter an accepting state if all checks succeed</li>
</ul>

<p>Why we need non-determinism:</p>

<ul>
  <li>need to “guess” where middle of the stack is</li>
  <li>cannot work this out and then check string
    <ul>
      <li>would need an unbounded number of states as the string could be of any finite length</li>
    </ul>
  </li>
</ul>

<p>Palindrome example:</p>

<p><img src="/cs-notes/assets/images/algs/pushdown_2.png" nopin="nopin" /></p>

<ul>
  <li>alphabet is <code class="highlighter-rouge"><span class="p">{</span><span class="err">a,</span><span class="w"> </span><span class="err">b</span><span class="p">}</span></code></li>
  <li><code class="highlighter-rouge">s0</code> is start state and <code class="highlighter-rouge">s0</code> and <code class="highlighter-rouge">s3</code> are the only accepting states</li>
  <li><code class="highlighter-rouge">(s0, ε, ε) --&gt; (s1, $)</code> move to <code class="highlighter-rouge">s1</code> and push <code class="highlighter-rouge">$</code> onto stack</li>
  <li><code class="highlighter-rouge">(s1, a, ε) --&gt; (s1, 1)</code> read <code class="highlighter-rouge">a</code> and push <code class="highlighter-rouge">1</code></li>
  <li><code class="highlighter-rouge">(s1, b, 1) --&gt; (s2, ε)</code> read <code class="highlighter-rouge">b</code> and <code class="highlighter-rouge">1</code> is on top, pop, move to <code class="highlighter-rouge">s2</code></li>
  <li><code class="highlighter-rouge">(s2, b, 1) --&gt; (s2, ε)</code> read <code class="highlighter-rouge">b</code> and <code class="highlighter-rouge">1</code> is on top, pop</li>
  <li><code class="highlighter-rouge">(s2, ε, $) --&gt; (s3, ε)</code> if <code class="highlighter-rouge">$</code> is top, pop, move to <code class="highlighter-rouge">s3</code></li>
</ul>

<p>So the automaton recognises the language { (a<sup>n</sup>b<sup>n</sup>)<code class="highlighter-rouge"> |</code> n =&gt; 0 }</p>

<p>PDA are more powerful than finite-state - can recognise languages that a DFA cannot<br />
   These languages are the <strong>context-free languages</strong><br />
   Not all languages are context-free, for example, { (a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>)<code class="highlighter-rouge"> |</code> n =&gt; 0 } cannot be recognised by a PDA</p>

<p><strong>Turing Machines:</strong></p>

<p>Recognises a particular languages consisting of:</p>

<ul>
  <li>finite alphabet <code class="highlighter-rouge">Σ</code>, including blank symbol <code class="highlighter-rouge">#</code></li>
  <li>unbounded <strong>tape</strong> of squares
    <ul>
      <li>each holding a single symbol of <code class="highlighter-rouge">Σ</code></li>
      <li>unbounded in both directions</li>
    </ul>
  </li>
  <li><strong>tape head</strong> that scans a single square
    <ul>
      <li>read and write to square</li>
      <li>moves 1 square left/right along the tape</li>
    </ul>
  </li>
  <li>set <code class="highlighter-rouge">S</code> of <strong>states</strong>
    <ul>
      <li>start state <code class="highlighter-rouge">s0</code> and two <strong>halt</strong> (or terminal) states <code class="highlighter-rouge">sY</code> and <code class="highlighter-rouge">sN</code></li>
    </ul>
  </li>
  <li><strong>transition function</strong>
    <ul>
      <li>the inbuilt program</li>
      <li>of the form <code class="highlighter-rouge">f: ((S/{sY, sN}) * Σ) --&gt; (S * Σ * {left, right})</code></li>
    </ul>
  </li>
</ul>

<p>For each non-terminal state and symbol, <code class="highlighter-rouge">f</code> specifies</p>

<ul>
  <li>a new state</li>
  <li>a new symbol</li>
  <li>a direction in which to move</li>
</ul>

<p><code class="highlighter-rouge">f(s, σ) = (s', σ', d)</code> means reading <code class="highlighter-rouge">σ</code> from the tape in state <code class="highlighter-rouge">s</code></p>

<ul>
  <li>move to state <code class="highlighter-rouge">s' ∈ S</code></li>
  <li>overwrite <code class="highlighter-rouge">σ</code> with <code class="highlighter-rouge">σ ∈ Σ</code></li>
  <li>move head in the direction <code class="highlighter-rouge">d ∈ {left, right}</code></li>
</ul>

<p>Computation:</p>

<ul>
  <li>finite input string placed on tape</li>
  <li>head placed on first symbol of the input</li>
  <li>starts in state <code class="highlighter-rouge">s0</code>
    <ul>
      <li>if halts in state <code class="highlighter-rouge">sY</code>, answer is “yes”</li>
      <li>if halts in state <code class="highlighter-rouge">sN</code>, answer is “no”</li>
    </ul>
  </li>
</ul>

<p>Palindrome problem:<br />
   Instance: finite string <code class="highlighter-rouge">Y</code>
   Question: is <code class="highlighter-rouge">Y</code> a palindrome?<br />
   Java <a href="#turing_palindrome">method</a> for this</p>

<p>We can use a Turing machine for this problem, as we don’t need nondeterminism (don’t need to guess the middle)</p>

<p><a href="#turing_palindrome_2">TM algorithm</a> for the palindrome problem</p>

<p>For this, we need the following states:</p>

<ul>
  <li><code class="highlighter-rouge">s0</code> reading, erasing and remember leftmost symbol</li>
  <li><code class="highlighter-rouge">s1, s2</code> moving right, remembering symbol erased</li>
  <li><code class="highlighter-rouge">s3, s4</code> testing for appropritate rightmost symbol</li>
  <li><code class="highlighter-rouge">s5</code> moving back to leftmost symbol</li>
</ul>

<p>A TM can be described with a <strong>state transition diagram</strong><br />
   A directed graph where</p>

<ul>
  <li>each state represented by vertex</li>
  <li><code class="highlighter-rouge">f(s, σ) = (s', σ', d)</code> represented by an edge from <code class="highlighter-rouge">s</code> to <code class="highlighter-rouge">s'</code> labelled <code class="highlighter-rouge">(σ --&gt; σ', d)</code>
    <ul>
      <li>edge represents moving to <code class="highlighter-rouge">s'</code></li>
      <li><code class="highlighter-rouge">σ --&gt; σ'</code> represents overwriting symbol on tape</li>
      <li><code class="highlighter-rouge">d</code> represents moving tape in a direction <code class="highlighter-rouge">d</code></li>
    </ul>
  </li>
</ul>

<p><img src="/cs-notes/assets/images/algs/turing.png" nopin="nopin" /></p>

<p>Functions:</p>

<p>TM that accepts language <code class="highlighter-rouge">L</code> actually computes the function <code class="highlighter-rouge">f</code> where <code class="highlighter-rouge">f(s) = 1</code> if <code class="highlighter-rouge">s ∈ L</code> and <code class="highlighter-rouge">0</code> otherwise</p>

<p>The definition of a TM can be amended as follows:</p>

<ul>
  <li>to have set <code class="highlighter-rouge">H</code> of halt states</li>
  <li>function it computers is defined by <code class="highlighter-rouge">f(s) = s'</code> where
    <ul>
      <li><code class="highlighter-rouge">s</code> is inital string</li>
      <li><code class="highlighter-rouge">s'</code> is string on tape when the machine halts</li>
    </ul>
  </li>
</ul>

<p>eg, the palindrome TM can be redefined such that it deletes the tape contents and</p>

<ul>
  <li>instead of entering <code class="highlighter-rouge">sY</code>, it writes <code class="highlighter-rouge">1</code> on tape and enters halt state</li>
  <li>instead of entering <code class="highlighter-rouge">sN</code>, it writes <code class="highlighter-rouge">0</code> on tape and enters halt state</li>
</ul>

<p>Designing a TM to compute <code class="highlighter-rouge">f(k) = k + 1</code>:</p>

<ol>
  <li>input 1 0 0 0 1 0, output 1 0 0 0 1 1
    <ul>
      <li>pattern: replace rightmost <code class="highlighter-rouge">0</code> with <code class="highlighter-rouge">0</code></li>
      <li>then moving right: if <code class="highlighter-rouge">1</code>, replace with <code class="highlighter-rouge">0</code> and continue right / if blank, halt</li>
    </ul>
  </li>
  <li>input 1 0 0 1 1 1, output 1 0 1 0 0 0
    <ul>
      <li>same pattern as 1</li>
    </ul>
  </li>
  <li>input 1 1 1 1 1, output 1 0 0 0 0 0
    <ul>
      <li>this is a special case</li>
      <li>no rightmost <code class="highlighter-rouge">0</code></li>
      <li>replace first blank before input with <code class="highlighter-rouge">1</code></li>
      <li>then moving right: if <code class="highlighter-rouge">1</code> replace with <code class="highlighter-rouge">0</code> and continue right / if blank, halt</li>
    </ul>
  </li>
</ol>

<p><a href="#turing_example">TM algorithm</a> for the above function</p>

<p>For this, we need the following states:</p>

<ul>
  <li><code class="highlighter-rouge">s0</code> initial state moving right seeking start of input</li>
  <li><code class="highlighter-rouge">s1</code> moving left to rightmost <code class="highlighter-rouge">0</code> or blank</li>
  <li><code class="highlighter-rouge">s2</code> finding first <code class="highlighter-rouge">0</code> or blank, changing it to <code class="highlighter-rouge">1</code> and moving right, changing <code class="highlighter-rouge">1</code>s to <code class="highlighter-rouge">0</code>s</li>
  <li><code class="highlighter-rouge">s3</code> halt state</li>
</ul>

<p><strong>Recognisable and decidable:</strong></p>

<p>Language <code class="highlighter-rouge">L</code> is <strong>Turing-recognisable</strong> if, given input string <code class="highlighter-rouge">s</code>:</p>

<ul>
  <li>if <code class="highlighter-rouge">s ∈ L</code>, then TM halts in state <code class="highlighter-rouge">sY</code></li>
  <li>if <code class="highlighter-rouge">s Ï L</code>, then TM halts in state <code class="highlighter-rouge">sN</code> or fails to halt</li>
</ul>

<p>Language <code class="highlighter-rouge">L</code> is <strong>Turing-decidable</strong> if, given input string <code class="highlighter-rouge">s</code>:</p>

<ul>
  <li>if <code class="highlighter-rouge">s ∈ L</code>, then TM halts in state <code class="highlighter-rouge">sY</code></li>
  <li>if <code class="highlighter-rouge">s Ï L</code>, then TM halts in state <code class="highlighter-rouge">sN</code></li>
</ul>

<p>Every decidable language is recognisable, but not every recognisable language is decidable</p>

<p>A function <code class="highlighter-rouge">f: S* --&gt; S*</code> is <strong>Turing-computable</strong> if there is a TM <code class="highlighter-rouge">M</code> such that, for any input <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">M</code> halts with output <code class="highlighter-rouge">f(s)</code></p>

<p><strong>Enhanced Turing Machines:</strong></p>

<p>TM can be enhanced in a few ways</p>

<ul>
  <li>2+ tapes, rather than just one</li>
  <li>a 2-dimensional “tape”</li>
  <li>TM may operate non-deterministically (transition function may be a relation instead)</li>
</ul>

<p>None of these enhancements change the computing power</p>

<ul>
  <li>every lang./func. that is recognisable/decidable/computable with an enhanced TM is also R/D/C with a basic TM
    <ul>
      <li>non-determinism adds power to PDA, but not to DFAs nor TMs</li>
    </ul>
  </li>
  <li>proved by showing that basic TM can simulate any of these enhanced TMs</li>
</ul>

<p><strong>P and NP:</strong></p>

<p>P often introduced as the class as decision problems solvable by a TM in poly-time<br />
   NP introduced as the class of decision problems solvable by a non-deterministic TM in poly-time</p>

<ul>
  <li>in a non-deterministic TM, transition function replaced by a relation <code class="highlighter-rouge">f ⊆ ( (S * Σ) * (S * Σ * {left, right}) )</code>
    <ul>
      <li>can make a number of different transition based on current state and symbol at head</li>
    </ul>
  </li>
  <li>non-det. doesn’t change what can be computed, but speeds it up</li>
</ul>

<p>To show P ≠ NP, sufficient to show that a standard TM cannot solve an NP-complete problem in poly-time</p>

<p><strong>Counter-programs:</strong></p>

<p>These have</p>

<ul>
  <li>vartiables of type <code class="highlighter-rouge">int</code></li>
  <li>labelled statements of the form <code class="highlighter-rouge">L: unlabelled_statement</code></li>
  <li>unlabelled statements of the form
    <ul>
      <li><code class="highlighter-rouge">x = 0</code></li>
      <li><code class="highlighter-rouge">x = y + 1</code></li>
      <li><code class="highlighter-rouge">x = y - 1</code></li>
      <li><code class="highlighter-rouge">if x == 0 goto L</code></li>
      <li><code class="highlighter-rouge">halt;</code></li>
    </ul>
  </li>
</ul>

<p>Counter program <a href="#counter_program">example</a></p>

<p><strong>Church-Turing thesis:</strong></p>

<p>Based on the fact that a whole range of different computational models turn out to be equivalent in terms of what they can compute<br />
   Reasonable to infer that any one of these models encapsulates what is effectively computable<br />
   This thesis states that everything “effectively computable” is computable by a TM (not a theorem as uses informal terms)<br />
   So there is an effective procedure for computing the value of the function, including all computers/programming langs. that we know about at present and even those we do not</p>

<p>So the TM is an appropriate model for the “black box”</p>

<p>Equivalent computational models (each can “simulate” the others):</p>

<ul>
  <li>lambda calculus (Church)</li>
  <li>TMs (Turing)</li>
  <li>recursive functions (Kleene)</li>
  <li>production systems (Post)</li>
  <li>counter programs and all general purpose programming languages</li>
</ul>

<p><a name="heap_class"></a></p>

<h6 id="heap-class-implementation-in-java">Heap class implementation in Java</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">public</span> <span class="kr">class</span> <span class="nx">Heap</span> <span class="p">{</span>

  <span class="kr">int</span> <span class="nx">size</span><span class="p">;</span>
  <span class="kr">int</span><span class="p">[]</span> <span class="nx">items</span><span class="p">;</span>
  
  <span class="c1">// create empty heap of max capacity n</span>
  <span class="kr">public</span> <span class="nx">Heap</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">int</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
    
  <span class="p">}</span>
  
  <span class="c1">// create heap of capacity n containing items from array a</span>
  <span class="kr">public</span> <span class="nx">Heap</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">,</span> <span class="kr">int</span><span class="p">[]</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="nx">size</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">int</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">build</span><span class="p">();</span> <span class="c1">// impose heap property</span>
    
  <span class="p">}</span>
  
<span class="p">}</span>

<span class="c1">// build a heap on current items</span>
<span class="kr">private</span> <span class="k">void</span> <span class="nx">build</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// for each non-leaf node in bottom-to-top right-to-left order</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="c1">// start at parent of final leaf</span>
    <span class="nx">impose</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    
<span class="p">}</span>

<span class="c1">// insert item k</span>
<span class="kr">public</span> <span class="k">void</span> <span class="nx">insert</span><span class="p">(</span><span class="kr">int</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="nx">size</span><span class="o">++</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// current position(starting at new leaf node)</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//swap with parent</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// new position is position of parent</span>
  <span class="p">}</span>
  
  <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">k</span><span class="p">;</span> <span class="c1">// finalise location of item</span>

<span class="p">}</span>

<span class="c1">// delete and return the max</span>
<span class="kr">public</span> <span class="kr">int</span> <span class="nx">deleteMax</span><span class="p">()</span> <span class="p">{</span>
  
  <span class="kr">int</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// root</span>
  <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// swap root with last leaf</span>
  <span class="nx">size</span><span class="o">--</span><span class="p">;</span>
  <span class="nx">impose</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// on bad value in root</span>
  <span class="k">return</span> <span class="nx">k</span><span class="p">;</span>
  
<span class="p">}</span>

<span class="c1">// impose property on node i</span>
<span class="kr">private</span> <span class="k">void</span> <span class="nx">impose</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="kr">int</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="kr">int</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="kr">boolean</span> <span class="nx">finished</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">current</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">finished</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="c1">// find larger child</span>
    <span class="kr">int</span> <span class="nx">next</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">current</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// assume left child first</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">next</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">size</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">next</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">next</span><span class="p">])</span>
      <span class="nx">next</span><span class="o">++</span><span class="p">;</span> <span class="c1">// change if right exists and is larger</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">temp</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">next</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// bad node</span>
      <span class="nx">items</span><span class="p">[</span><span class="nx">current</span><span class="p">]</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">next</span><span class="p">];</span> <span class="c1">// swap</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span> <span class="c1">// new position</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nx">finished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// not bad node</span>
  <span class="p">}</span>
  
  <span class="nx">items</span><span class="p">[</span><span class="nx">current</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span> <span class="c1">// finalise location</span>

<span class="p">}</span>
</code></pre>
</div>
<p><a name="heap_sort"></a></p>

<h6 id="heapsort-pseudocode">Heapsort pseudocode</h6>

<ul>
  <li><strong>Build</strong> sequence into a heap; // O(n)
    <ul>
      <li>for (int k = 0; k &lt; n-1; k++)</li>
      <li>// invariant: items 0,…,n-k-1 form a heap</li>
      <li>// invariant: items n-k,…,n-1 are sorted</li>
      <li><strong>Find</strong> the largest unsorted item; // is in position 0, so O(1)</li>
      <li><strong>Swap</strong> it into position n-1-k; // its correct place O(1)</li>
      <li><strong>Reduce</strong> the size of the heap by 1; // O(1)</li>
      <li><strong>Impose</strong> the heap property on position 0; // this is O(log n)</li>
    </ul>
  </li>
  <li><strong>Restore</strong> size to original value;</li>
</ul>

<p>Loop is iterated <code class="highlighter-rouge">n - 1</code> times<br />
   Each iteration takes O(log n) time</p>

<p><a name="radix_sort"></a></p>

<h6 id="radix-sort-pseudocode">Radix sort pseudocode</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">private</span> <span class="kr">int</span> <span class="nx">bits</span><span class="p">(</span><span class="nx">Item</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">b</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">p</span><span class="p">)</span> <span class="c1">// helper method which would return the value represented by the b bits of x when starting at position p</span>

<span class="c1">// a is the sequence to be sorted</span>
<span class="c1">// m is the number of bits in each item of a</span>
<span class="c1">// b is the block length of radix sort</span>

<span class="kr">int</span> <span class="nx">numIterations</span> <span class="o">=</span> <span class="nx">m</span><span class="o">/</span><span class="nx">b</span><span class="p">;</span>
<span class="kr">int</span> <span class="nx">numBuckets</span> <span class="o">=</span> <span class="p">(</span><span class="kr">int</span><span class="p">)</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

<span class="nx">ArrayList</span><span class="o">&lt;</span><span class="nx">Item</span><span class="o">&gt;</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArraList</span><span class="o">&lt;&gt;</span><span class="p">();</span> <span class="c1">// sequence a</span>

<span class="c1">// representing the buckets</span>
<span class="nx">ArrayList</span><span class="o">&lt;</span><span class="nx">Item</span><span class="o">&gt;</span><span class="p">[]</span> <span class="nx">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayList</span><span class="p">[</span><span class="nx">numBuckets</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numBuckets</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayList</span><span class="o">&lt;</span><span class="nx">Item</span><span class="o">&gt;</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">numIterations</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// clear buckets</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">numBuckets</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">clear</span><span class="p">();</span>
  
  <span class="c1">// distribute items in order</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">Item</span> <span class="nx">x</span> <span class="err">:</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">int</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">bits</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// find correct bucket</span>
	<span class="nx">bucket</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">a</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span> <span class="c1">// clear sequence</span>
  
  <span class="c1">// concatenate buckets in order</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">numBuckets</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="nx">a</span><span class="p">.</span><span class="nx">addAll</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">]);</span>
  
<span class="p">}</span>
</code></pre>
</div>

<p><a name="trie_alg"></a></p>

<h6 id="tries-1">Tries</h6>

<p><strong>Search:</strong></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// search for a word w in a trie t</span>
<span class="nx">Node</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">root</span> <span class="nx">of</span> <span class="nx">t</span><span class="p">;</span>
<span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current position in w</span>

<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">has</span> <span class="nx">a</span> <span class="nx">child</span> <span class="nx">c</span> <span class="nx">labelled</span> <span class="nx">w</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// if can match the char of word in the current position</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">w</span><span class="p">.</span><span class="nx">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// end of word</span>
	  <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">is</span> <span class="nx">an</span> <span class="s2">"intermediate"</span> <span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="s2">"absent"</span><span class="p">;</span>
	  <span class="k">else</span> <span class="k">return</span> <span class="s2">"present"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span> <span class="c1">// not at end of word</span>
	  <span class="nx">n</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// move to child</span>
	  <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// move to next char</span>
	<span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">return</span> <span class="s2">"absent"</span><span class="p">;</span> <span class="c1">// can't match current char</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Insert:</strong></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// insert word w into trie t</span>
<span class="nx">Node</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">root</span> <span class="nx">of</span> <span class="nx">t</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">w</span><span class="p">.</span><span class="nx">length</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// go through chars of word</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">has</span> <span class="nx">no</span> <span class="nx">child</span> <span class="nx">c</span> <span class="nx">labelled</span> <span class="nx">w</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">create</span> <span class="nx">such</span> <span class="nx">a</span> <span class="nx">child</span> <span class="nx">c</span><span class="p">;</span>
	<span class="nx">mark</span> <span class="nx">c</span> <span class="nx">as</span> <span class="nx">intermediate</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// move to child node</span>
<span class="p">}</span>
<span class="nx">mark</span> <span class="nx">n</span> <span class="nx">as</span> <span class="nx">representing</span> <span class="nx">a</span> <span class="nx">word</span><span class="p">;</span>
</code></pre>
</div>

<p><a name="trie_class"></a></p>

<h6 id="trie-class">Trie class</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">public</span> <span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>

  <span class="kr">private</span> <span class="kr">char</span> <span class="nx">letter</span><span class="p">;</span> <span class="c1">// label of incoming branch</span>
  <span class="kr">private</span> <span class="kr">boolean</span> <span class="nx">isWord</span><span class="p">;</span> <span class="c1">// true when node represents a word</span>
  <span class="kr">private</span> <span class="nx">Node</span> <span class="nx">sibling</span><span class="p">;</span> <span class="c1">// next sibling</span>
  <span class="kr">private</span> <span class="nx">Node</span> <span class="nx">child</span><span class="p">;</span> <span class="c1">// first child</span>
  
  <span class="kr">public</span> <span class="nx">Node</span><span class="p">(</span><span class="kr">char</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="nx">letter</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
	<span class="nx">isWord</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
	<span class="nx">sibling</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
	<span class="nx">child</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
	
  <span class="p">}</span>
  <span class="c1">// include accessors and mutators for the various components of a class</span>
<span class="p">}</span>

<span class="kr">public</span> <span class="kr">class</span> <span class="nx">Trie</span> <span class="p">{</span>

  <span class="kr">private</span> <span class="nx">Node</span> <span class="nx">root</span><span class="p">;</span>
  
  <span class="kr">public</span> <span class="nx">Trie</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">Character</span><span class="p">.</span><span class="nx">MIN_VALUE</span><span class="p">);</span>
  <span class="p">}</span>
  
<span class="p">}</span>
</code></pre>
</div>

<p><a name="huff_contruct"></a></p>

<h6 id="huffman-tree-construction">Huffman tree construction</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// set up leaf nodes</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">distinct</span> <span class="kr">char</span> <span class="nx">c</span> <span class="nx">occuring</span> <span class="k">in</span> <span class="nx">the</span> <span class="nx">file</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">make</span> <span class="nx">a</span> <span class="k">new</span> <span class="nx">parentless</span> <span class="nx">node</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">frequency</span> <span class="nx">count</span> <span class="k">for</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">setWeight</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">setCharacter</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">setLeftChild</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">setRightChild</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  
<span class="p">}</span>

<span class="c1">// construct branch nodes and links</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">num</span> <span class="nx">of</span> <span class="nx">parentless</span> <span class="nx">nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">make</span> <span class="nx">a</span> <span class="k">new</span> <span class="nx">parentless</span> <span class="nx">node</span> <span class="nx">z</span><span class="p">;</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">the</span> <span class="mi">2</span> <span class="nx">parentless</span> <span class="nx">nodes</span> <span class="nx">of</span> <span class="nx">minimum</span> <span class="nx">weight</span><span class="p">;</span>
  <span class="nx">z</span><span class="p">.</span><span class="nx">setLeftChild</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">z</span><span class="p">.</span><span class="nx">setRightChild</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="kr">int</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">getWeight</span><span class="p">()</span> <span class="o">+</span> <span class="nx">y</span><span class="p">.</span><span class="nx">getWeight</span><span class="p">();</span>
  <span class="nx">z</span><span class="p">.</span><span class="nx">setWeight</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>
  
<span class="p">}</span>
<span class="c1">// the final z is root</span>
</code></pre>
</div>

<p><a name="lzw"></a></p>

<h6 id="lzw-compression-1">LZW compression</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">set</span> <span class="nx">current</span> <span class="nx">text</span> <span class="nx">position</span> <span class="nx">i</span> <span class="nx">to</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">initialise</span> <span class="nx">codeword</span> <span class="nx">length</span> <span class="nx">k</span><span class="p">;</span>
<span class="nx">initialise</span> <span class="nx">dictionary</span> <span class="nx">d</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">text</span> <span class="nx">t</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">exhausted</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="nx">identify</span> <span class="nx">longest</span> <span class="nx">string</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">starting</span> <span class="nx">at</span> <span class="nx">position</span> <span class="nx">i</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">text</span> <span class="nx">that</span> <span class="nx">is</span> <span class="nx">represented</span> <span class="k">in</span> <span class="nx">d</span><span class="p">;</span>
  <span class="nx">output</span> <span class="nx">codeword</span> <span class="k">for</span> <span class="nx">s</span><span class="p">;</span> <span class="c1">// using k bits</span>
  
  <span class="c1">// move to next position in t</span>
  <span class="nx">i</span> <span class="o">+=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">();</span> <span class="c1">// move forward by the length of the string just encoded</span>
  <span class="nx">c</span> <span class="o">=</span> <span class="kr">char</span> <span class="nx">at</span> <span class="nx">position</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">t</span><span class="p">;</span> <span class="c1">// char in next position</span>
  
  <span class="nx">add</span> <span class="nx">string</span> <span class="nx">s</span><span class="o">+</span><span class="nx">c</span> <span class="nx">to</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">paired</span> <span class="kd">with</span> <span class="nx">next</span> <span class="nx">available</span> <span class="nx">codeword</span><span class="p">;</span> <span class="c1">// involves adding a new leaf node if d is represented by a trie</span>
  
<span class="p">}</span>
</code></pre>
</div>

<p><a name="lzw_decomp"></a></p>

<h6 id="lzw-decompression">LZW decompression</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">initialise</span> <span class="nx">codeword</span> <span class="nx">length</span> <span class="nx">k</span><span class="p">;</span>
<span class="nx">initialise</span> <span class="nx">dictionary</span> <span class="nx">d</span><span class="p">;</span>

<span class="nx">read</span> <span class="nx">first</span> <span class="nx">codeword</span> <span class="nx">x</span> <span class="nx">from</span> <span class="nx">the</span> <span class="nx">compressed</span> <span class="nx">file</span> <span class="nx">f</span><span class="p">;</span> <span class="c1">// read k bits</span>
<span class="nb">String</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">lookUp</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// look up codeword in d</span>
<span class="nx">output</span> <span class="nx">s</span><span class="p">;</span> <span class="c1">// output decompressed string</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">exhausted</span><span class="p">)</span> <span class="p">{</span>

  <span class="nb">String</span> <span class="nx">oldS</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span> <span class="c1">// copy last string decompressed</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">is</span> <span class="nx">full</span><span class="p">)</span> <span class="nx">k</span><span class="o">++</span><span class="p">;</span>
  
  <span class="nx">get</span> <span class="nx">next</span> <span class="nx">codeword</span> <span class="nx">x</span> <span class="nx">from</span> <span class="nx">f</span><span class="p">;</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">loopUp</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// look up codeword in d</span>
  <span class="nx">output</span> <span class="nx">s</span><span class="p">;</span> <span class="c1">// output decompressed string</span>
  
  <span class="nb">String</span> <span class="nx">newS</span> <span class="o">=</span> <span class="nx">oldS</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// string to add to d</span>
  <span class="nx">add</span> <span class="nx">newS</span> <span class="nx">to</span> <span class="nx">d</span> <span class="nx">paired</span> <span class="kd">with</span> <span class="nx">next</span> <span class="nx">available</span> <span class="nx">codeword</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="brute_force"></a></p>

<h6 id="brute-force-algorithm-1">Brute force algorithm</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// return smallest k such that s occurs in t starting at position k, or -1 if no k exists</span>
<span class="kr">public</span> <span class="kr">int</span> <span class="nx">bruteForce</span><span class="p">(</span><span class="kr">char</span><span class="p">[]</span> <span class="nx">t</span><span class="p">,</span> <span class="kr">char</span><span class="p">[]</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">int</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// length of string/pattern</span>
  <span class="kr">int</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// length of text</span>
  <span class="kr">int</span> <span class="nx">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// starting position in t</span>
  <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// curr position in t</span>
  <span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// curr position in s</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="nx">sp</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="o">-</span><span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// not reached end</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// chars match</span>
	  <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// move on in t</span>
	  <span class="nx">j</span><span class="o">++</span> <span class="c1">// move on in s</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	  <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// start again in s</span>
	  <span class="nx">sp</span><span class="o">++</span><span class="p">;</span> <span class="c1">// advance starting position</span>
	  <span class="nx">i</span> <span class="o">=</span> <span class="nx">sp</span><span class="p">;</span> <span class="c1">// back up in text to new starting position</span>
	<span class="p">}</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="nx">m</span><span class="p">)</span> <span class="k">return</span> <span class="nx">sp</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
<span class="p">}</span>
</code></pre>
</div>

<p><a name="kmp"></a></p>

<h6 id="kmp-search-implementation">KMP search implementation</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// return smallest k such that s occurs from position k in t, or -1 if no k exists</span>
<span class="kr">public</span> <span class="kr">int</span> <span class="nx">kmp</span><span class="p">(</span><span class="kr">char</span><span class="p">[]</span> <span class="nx">t</span><span class="p">,</span> <span class="kr">char</span><span class="p">[]</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="kr">int</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">int</span> <span class="p">[]</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">int</span><span class="p">[</span><span class="nx">m</span><span class="p">];</span> <span class="c1">// create border table</span>
  
  <span class="nx">setUp</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// set up border table</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// not reached end of text</span>
  
    <span class="k">if</span> <span class="p">([</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// positions match</span>
	  <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// move on in text</span>
	  <span class="nx">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// move on in string</span>
	  <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">m</span><span class="p">)</span> <span class="k">return</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// reached end of string so a match</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// mismatch so adjust curr position in string using border table</span>
	  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span> <span class="c1">// if there is a common prefix/suffix then change position in string</span>
	  <span class="k">else</span> <span class="p">{</span> <span class="c1">// no common prefix/suffix</span>
	    <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// then move forward 1 position in text if not advanced</span>
		<span class="k">else</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// else start from beginning of string</span>
	  <span class="p">}</span>
	<span class="p">}</span>
  
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// no occurence</span>
  
<span class="p">}</span>
</code></pre>
</div>

<p><a name="bm"></a></p>

<h6 id="boyer-moore-implementation">Boyer-Moore implementation</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// return smallest k such that s occurs at k in t, or -1 if no k exists</span>
<span class="kr">public</span> <span class="kr">int</span> <span class="nx">bm</span><span class="p">(</span><span class="kr">char</span><span class="p">[]</span> <span class="nx">t</span><span class="p">,</span> <span class="kr">char</span><span class="p">[]</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>

  <span class="kr">int</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// pos in text</span>
  <span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// pos in string</span>
  <span class="c1">// declare a suitable array p</span>
  <span class="nx">setUp</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span> <span class="c1">// set up last occurence array</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="nx">sp</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="o">-</span><span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// match</span>
	  <span class="nx">i</span><span class="o">--</span><span class="p">;</span> <span class="c1">// move back in text</span>
	  <span class="nx">j</span><span class="o">--</span><span class="p">;</span> <span class="c1">// move back in string</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	  <span class="nx">sp</span> <span class="o">+=</span> <span class="nx">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="nx">p</span><span class="p">[</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
	  <span class="nx">i</span> <span class="o">+=</span> <span class="nx">m</span> <span class="o">-</span> <span class="nx">min</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">p</span><span class="p">[</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
	  <span class="nx">j</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// return to end of string</span>
	<span class="p">}</span>
  
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">sp</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="adjacency_list"></a></p>

<h6 id="adjacency-list-implementation">Adjacency list implementation</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// an entry in the adjacency list</span>
<span class="kr">public</span> <span class="kr">class</span> <span class="nx">AdjListNode</span> <span class="p">{</span>

  <span class="kr">private</span> <span class="kr">int</span> <span class="nx">vertexIndex</span><span class="p">;</span>
  <span class="c1">// possibly other fields eg weight, capacity...</span>
  
  <span class="kr">public</span> <span class="nx">AjdListNode</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vertexIndex</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kr">public</span> <span class="kr">int</span> <span class="nx">getVertexIndex</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">vertexIndex</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">public</span> <span class="k">void</span> <span class="nx">setVertexIndex</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vertexIndex</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// a vertex</span>
<span class="kr">import</span> <span class="nx">java</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">LinkedList</span><span class="p">;</span>
<span class="kr">public</span> <span class="kr">class</span> <span class="nx">Vertex</span> <span class="p">{</span>

  <span class="kr">private</span> <span class="kr">int</span> <span class="nx">index</span><span class="p">;</span> <span class="c1">// the index of this vertex</span>
  <span class="kr">private</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">AjdListNode</span><span class="o">&gt;</span> <span class="nx">adjList</span><span class="p">;</span> <span class="c1">// and its adjacency list</span>
  <span class="c1">// possibly other fields eg storing data</span>
  
  <span class="kr">public</span> <span class="nx">Vertex</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">adjList</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">AjdListNode</span><span class="o">&gt;</span><span class="p">();</span>
	<span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kr">public</span> <span class="kr">int</span> <span class="nx">getIndex</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">index</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">public</span> <span class="k">void</span> <span class="nx">setIndex</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">index</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// add vertex with index m to the adj list</span>
  <span class="kr">public</span> <span class="k">void</span> <span class="nx">addToAdjList</span><span class="p">(</span><span class="kr">int</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">adjList</span><span class="p">.</span><span class="nx">addLast</span><span class="p">(</span><span class="k">new</span> <span class="nx">AjdListNode</span><span class="p">(</span><span class="nx">m</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kr">public</span> <span class="kr">int</span> <span class="nx">vertexDegree</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">adjList</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// a graph</span>
<span class="kr">import</span> <span class="nx">java</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">LinkedList</span><span class="p">;</span>
<span class="kr">public</span> <span class="kr">class</span> <span class="nx">Graph</span> <span class="p">{</span>

  <span class="kr">private</span> <span class="nx">Vertex</span><span class="p">[]</span> <span class="nx">vertices</span><span class="p">;</span>
  <span class="kr">private</span> <span class="kr">int</span> <span class="nx">numVertices</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// possibly other fields for graph properties</span>
  
  <span class="c1">// create graph with vertices indexed 0,..., n-1</span>
  <span class="kr">public</span> <span class="nx">Graph</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">numVertices</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
	<span class="nx">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vertex</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vertex</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="kr">public</span> <span class="kr">int</span> <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">numVertices</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="dfs"></a></p>

<h6 id="depth-first-search-implementation">Depth-first search implementation</h6>

<p>Add this to the previously defined <strong>vertex</strong> class:</p>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>   <span class="kr">private</span> <span class="kr">boolean</span> <span class="nx">visited</span><span class="p">;</span>
   <span class="kr">private</span> <span class="kr">int</span> <span class="nx">pred</span><span class="p">;</span> <span class="c1">// index of predecessor vertex</span>
   
   <span class="kr">public</span> <span class="kr">boolean</span> <span class="nx">getVisited</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">visited</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">public</span> <span class="k">void</span> <span class="nx">setVisited</span><span class="p">(</span><span class="kr">boolean</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">visited</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">public</span> <span class="kr">int</span> <span class="nx">getPred</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">pred</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">public</span> <span class="k">void</span> <span class="nx">setPred</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">pred</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
   <span class="p">}</span>
</code></pre>
</div>

<p>And add this to the previously defined <strong>graph</strong> class:</p>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>   <span class="c1">// visit vertex v with predecessor p</span>
   <span class="kr">private</span> <span class="k">void</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">Vertex</span> <span class="nx">v</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
   
     <span class="nx">v</span><span class="p">.</span><span class="nx">setVisited</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// update</span>
	 <span class="nx">v</span><span class="p">.</span><span class="nx">setPred</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// set predecessor (-1 if none)</span>
	 <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">AdjListNode</span><span class="o">&gt;</span> <span class="nx">L</span> <span class="o">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">getAjdList</span><span class="p">();</span> <span class="c1">// get adj. list</span>
	 
	 <span class="k">for</span> <span class="p">(</span><span class="nx">AdjListNode</span> <span class="nx">node</span> <span class="err">:</span> <span class="nx">L</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// go through all adjacent vertices</span>
	   <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">getIndex</span><span class="p">();</span>
	   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">getVisited</span><span class="p">())</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nx">getIndex</span><span class="p">());</span> <span class="c1">// if current vertex hasn't been visited, continue the search from there</span>
	 <span class="p">}</span>
	 
   <span class="p">}</span>
   
   <span class="c1">// carry out a df traversal</span>
   <span class="kr">public</span> <span class="k">void</span> <span class="nx">dfs</span><span class="p">()</span> <span class="p">{</span>
   
     <span class="k">for</span> <span class="p">(</span><span class="nx">Vertex</span> <span class="nx">v</span> <span class="err">:</span> <span class="nx">vertices</span><span class="p">)</span> <span class="nx">v</span><span class="p">.</span><span class="nx">setVisited</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// initialise</span>
	 <span class="k">for</span> <span class="p">(</span><span class="nx">Vertex</span> <span class="nx">v</span> <span class="err">:</span> <span class="nx">vertices</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">v</span><span class="p">.</span><span class="nx">getVisited</span><span class="p">())</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// if vertex not visited, start search there</span>
   
   <span class="p">}</span>
</code></pre>
</div>

<p><a name="bfs"></a></p>

<h6 id="breadth-first-search-implementation">Breadth-first search implementation</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="nx">Vertex</span> <span class="nx">v</span> <span class="err">:</span> <span class="nx">vertices</span><span class="p">)</span> <span class="nx">v</span><span class="p">.</span><span class="nx">setVisited</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// initialise</span>
<span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">Vertex</span><span class="o">&gt;</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">Vertex</span> <span class="nx">v</span> <span class="err">:</span> <span class="nx">vertices</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">v</span><span class="p">.</span><span class="nx">getVisited</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// start search</span>
  
    <span class="nx">v</span><span class="p">.</span><span class="nx">setVisited</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// now visited</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">setPredecessor</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// v initial vertex</span>
	<span class="nx">queue</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// ready to be processed</span>
	
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">queue</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
	
	  <span class="nx">Vertex</span> <span class="nx">u</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span> <span class="c1">// get next vertex to process</span>
	  <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">AdjListNode</span><span class="o">&gt;</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">getAdjList</span><span class="p">();</span> <span class="c1">// get its adj. list</span>
	  
	  <span class="k">for</span> <span class="p">(</span><span class="nx">AdjListNode</span> <span class="nx">node</span> <span class="err">:</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// go through its adj. list</span>
	  
	    <span class="nx">Vertex</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">vertices</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">getVertexIndex</span><span class="p">()];</span> <span class="c1">// next vertex in list</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">w</span><span class="p">.</span><span class="nx">getVisited</span><span class="p">())</span> <span class="p">{</span>
		  
		  <span class="nx">w</span><span class="p">.</span><span class="nx">setVisited</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// now visited</span>
		  <span class="nx">w</span><span class="p">.</span><span class="nx">setPredecessor</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">getIndex</span><span class="p">());</span> <span class="c1">// set predecessor of w to be u</span>
		  <span class="nx">queue</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span> <span class="c1">// add to queue</span>
		  
		<span class="p">}</span>
	  
	  <span class="p">}</span>
	
	<span class="p">}</span>
  
  <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="dijkstra"></a></p>

<h6 id="dijkstras-algorithm-implementation">Dijkstra’s algorithm implementation</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// S is set of vertices for which shortest path from u is known</span>
<span class="c1">// d(w) is length of a shortest path from u to w passing only through vertices of S</span>
<span class="nx">S</span> <span class="o">=</span> <span class="p">{</span><span class="nx">u</span><span class="p">};</span> <span class="c1">// initialise S</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">vertex</span> <span class="nx">w</span><span class="p">)</span> <span class="nx">d</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span> <span class="o">=</span> <span class="nx">wt</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="c1">// initialise distances</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">S</span> <span class="o">!=</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// still vertices to add in S</span>

  <span class="nx">find</span> <span class="nx">v</span> <span class="nx">not</span> <span class="k">in</span> <span class="nx">S</span> <span class="kd">with</span> <span class="nx">d</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="nx">minimum</span><span class="p">;</span>
  <span class="nx">add</span> <span class="nx">v</span> <span class="nx">to</span> <span class="nx">S</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">w</span> <span class="nx">not</span> <span class="k">in</span> <span class="nx">S</span> <span class="nx">and</span> <span class="nx">adjacent</span> <span class="nx">to</span> <span class="nx">v</span><span class="p">)</span> <span class="nx">d</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span> <span class="o">=</span> <span class="nx">min</span><span class="p">{</span> <span class="nx">d</span><span class="p">(</span><span class="nx">w</span><span class="p">),</span> <span class="nx">d</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nx">wt</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">};</span> <span class="c1">// perfom relaxation</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="non_deterministic"></a></p>

<h6 id="graph-colouring---example-of-a-non-deterministic-alg">Graph colouring - example of a non-deterministic alg.</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// return true if graph g is k-colourable</span>
<span class="kr">boolean</span> <span class="nx">nDGC</span><span class="p">(</span><span class="nx">Graph</span> <span class="nx">g</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">vertex</span> <span class="nx">v</span> <span class="err">:</span> <span class="nx">g</span><span class="p">)</span> <span class="nx">v</span><span class="p">.</span><span class="nx">setColour</span><span class="p">(</span><span class="nx">nonDeterministicChoice</span><span class="p">(</span><span class="nx">k</span><span class="p">));</span> <span class="c1">// guess a colour for each vertex</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">edge</span> <span class="p">{</span><span class="nx">u</span><span class="p">,</span><span class="nx">v</span><span class="p">}</span> <span class="err">:</span> <span class="nx">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">getColour</span><span class="p">()</span> <span class="o">==</span> <span class="nx">v</span><span class="p">.</span><span class="nx">getColour</span><span class="p">())</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// verify the colouring</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="prim_jarnik"></a></p>

<h6 id="prim-jarnik-algorithm-pseudocode">Prim-Jarnik algorithm pseudocode</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">set</span> <span class="nx">an</span> <span class="nx">arbitrary</span> <span class="nx">vertex</span> <span class="nx">r</span> <span class="nx">to</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">tree</span><span class="o">-</span><span class="nx">vertex</span> <span class="p">(</span><span class="nx">tv</span><span class="p">)</span>
<span class="nx">set</span> <span class="nx">all</span> <span class="nx">other</span> <span class="nx">vertices</span> <span class="nx">to</span> <span class="nx">be</span> <span class="nx">non</span><span class="o">-</span><span class="nx">tree</span><span class="o">-</span><span class="nx">vertices</span> <span class="p">(</span><span class="nx">ntv</span><span class="p">)</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">size</span> <span class="nx">of</span> <span class="nx">ntv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">find</span> <span class="nx">edge</span> <span class="nx">e</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">}</span> <span class="nx">of</span> <span class="nx">graph</span> <span class="nx">such</span> <span class="nx">that</span>
    <span class="nx">p</span> <span class="nx">is</span> <span class="nx">a</span> <span class="nx">tv</span><span class="p">;</span>
	<span class="nx">q</span> <span class="nx">is</span> <span class="nx">an</span> <span class="nx">ntv</span><span class="p">;</span>
	<span class="nx">wt</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="nx">is</span> <span class="nx">minimised</span><span class="p">;</span>
  <span class="nx">adjoin</span> <span class="nx">edge</span> <span class="nx">e</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">spanning</span> <span class="nx">tree</span><span class="p">;</span>
  <span class="nx">make</span> <span class="nx">q</span> <span class="nx">a</span> <span class="nx">tv</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="dijkstra_refinement"></a></p>

<h6 id="dijkstras-refinement-to-the-prim-jarnik-algorithm">Dijkstra’s refinement to the Prim-Jarnik algorithm</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">set</span> <span class="nx">an</span> <span class="nx">arbitrary</span> <span class="nx">vertex</span> <span class="nx">r</span> <span class="nx">to</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">tree</span><span class="o">-</span><span class="nx">vertex</span> <span class="p">(</span><span class="nx">tv</span><span class="p">)</span>
<span class="nx">set</span> <span class="nx">all</span> <span class="nx">other</span> <span class="nx">vertices</span> <span class="nx">to</span> <span class="nx">be</span> <span class="nx">non</span><span class="o">-</span><span class="nx">tree</span><span class="o">-</span><span class="nx">vertices</span> <span class="p">(</span><span class="nx">ntv</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">ntv</span> <span class="nx">s</span><span class="p">)</span> <span class="nx">set</span> <span class="nx">s</span><span class="p">.</span><span class="nx">bestTV</span> <span class="o">=</span> <span class="nx">r</span><span class="p">;</span> <span class="c1">// r is the only tv</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">size</span> <span class="nx">of</span> <span class="nx">ntv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">find</span> <span class="nx">ntv</span> <span class="nx">q</span> <span class="k">for</span> <span class="nx">which</span> <span class="nx">wt</span><span class="p">(</span> <span class="p">{</span><span class="nx">q</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">bestTV</span><span class="p">}</span> <span class="p">)</span> <span class="nx">is</span> <span class="nx">minimal</span><span class="p">;</span>
  <span class="nx">adjoin</span> <span class="p">{</span><span class="nx">q</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">bestTV</span><span class="p">}</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">tree</span><span class="p">;</span>
  <span class="nx">make</span> <span class="nx">q</span> <span class="nx">a</span> <span class="nx">tv</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">ntv</span> <span class="nx">s</span><span class="p">)</span> <span class="nx">update</span> <span class="nx">s</span><span class="p">.</span><span class="nx">bestTV</span><span class="p">;</span> <span class="c1">// update as tv set changed</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="topological_ordering"></a></p>

<h6 id="topological-ordering-algorithm">Topological ordering algorithm</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// assume each vertex has 2 integer attributes, label and count</span>
<span class="c1">// count is the number of incoming edges from unlabelled vertices</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">vertex</span> <span class="nx">v</span><span class="p">)</span> <span class="nx">v</span><span class="p">.</span><span class="nx">setCount</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">getInDegree</span><span class="p">());</span>
<span class="nx">set</span> <span class="nx">up</span> <span class="nx">empty</span> <span class="nx">sourceQueue</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">vertex</span> <span class="nx">v</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">getCount</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">add</span> <span class="nx">v</span> <span class="nx">to</span> <span class="nx">sourceQueue</span><span class="p">;</span> <span class="c1">// add vertices with no incoming edges</span>

<span class="kr">int</span> <span class="nx">nextLabel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// to give the topological order</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">sourceQueue</span> <span class="o">!</span><span class="nx">empty</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">take</span> <span class="nx">v</span> <span class="nx">from</span> <span class="nx">sourceQueue</span><span class="p">;</span>
  <span class="nx">v</span><span class="p">.</span><span class="nx">setLabel</span><span class="p">(</span><span class="nx">nextLabel</span><span class="o">++</span><span class="p">);</span> <span class="c1">// label the vertex</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">each</span> <span class="nx">w</span> <span class="kd">with</span> <span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="k">in</span> <span class="nx">E</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="nx">w</span><span class="p">.</span><span class="nx">setCount</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">getCount</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// update attribute count</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">getCount</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">add</span> <span class="nx">w</span> <span class="nx">to</span> <span class="nx">sourceQueue</span><span class="p">;</span> <span class="c1">// add vertex if no incoming vertices</span>
  
  <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="turing_palindrome"></a></p>

<h6 id="java-method-for-the-palindrome-problem">Java method for the palindrome problem</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">public</span> <span class="kr">boolean</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nb">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>

  <span class="kr">int</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

<span class="p">}</span>
</code></pre>
</div>

<p><a name="turing_palindrome_2"></a></p>

<h6 id="turing-machine-alg-for-the-palindrome-problem">Turing machine alg. for the palindrome problem</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">read</span> <span class="nx">symbol</span> <span class="k">in</span> <span class="nx">current</span> <span class="nx">square</span><span class="p">;</span>
<span class="nx">erase</span> <span class="k">this</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="nx">enter</span> <span class="nx">a</span> <span class="nx">state</span> <span class="nx">that</span> <span class="s2">"remembers"</span> <span class="nx">it</span><span class="p">;</span>
<span class="nx">move</span> <span class="nx">head</span> <span class="nx">to</span> <span class="nx">end</span> <span class="nx">of</span> <span class="nx">input</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">only</span> <span class="nx">blank</span> <span class="nx">chars</span><span class="p">.</span> <span class="nx">remain</span><span class="p">)</span>
  <span class="nx">enter</span> <span class="nx">accepting</span> <span class="nx">state</span> <span class="nx">and</span> <span class="nx">halt</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">last</span> <span class="kr">char</span><span class="p">.</span> <span class="nx">matches</span> <span class="nx">the</span> <span class="nx">one</span> <span class="nx">erased</span><span class="p">)</span>
  <span class="nx">erase</span> <span class="nx">it</span> <span class="nx">too</span><span class="p">;</span>
<span class="k">else</span> 
  <span class="nx">enter</span> <span class="nx">rejecting</span> <span class="nx">state</span> <span class="nx">and</span> <span class="nx">halt</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">no</span> <span class="nx">input</span> <span class="nx">left</span><span class="p">)</span>
  <span class="nx">enter</span> <span class="nx">accepting</span> <span class="nx">state</span> <span class="nx">and</span> <span class="nx">halt</span><span class="p">;</span>
<span class="k">else</span>
  <span class="nx">move</span> <span class="nx">to</span> <span class="nx">start</span> <span class="nx">of</span> <span class="nx">remaining</span> <span class="nx">input</span><span class="p">;</span>
  <span class="nx">repeat</span> <span class="nx">from</span> <span class="nx">first</span> <span class="nx">step</span><span class="p">;</span>
</code></pre>
</div>

<p><a name="turing_example"></a></p>

<h6 id="turing-machine-alg-for-the-function-fk--k--1">Turing Machine alg. for the function <code class="highlighter-rouge">f(k) = k + 1</code></h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">move</span> <span class="nx">right</span> <span class="nx">seeking</span> <span class="nx">first</span> <span class="nx">blank</span> <span class="nx">square</span><span class="p">;</span>
<span class="nx">move</span> <span class="nx">left</span> <span class="nx">looking</span> <span class="k">for</span> <span class="nx">first</span> <span class="mi">0</span> <span class="nx">or</span> <span class="nx">blank</span><span class="p">;</span>
<span class="nx">when</span> <span class="mi">0</span> <span class="nx">of</span> <span class="nx">blank</span> <span class="nx">found</span>
  <span class="nx">change</span> <span class="nx">it</span> <span class="nx">to</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">move</span> <span class="nx">right</span> <span class="nx">changing</span> <span class="nx">each</span> <span class="mi">1</span> <span class="nx">to</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">halt</span> <span class="nx">when</span> <span class="nx">blank</span> <span class="nx">square</span> <span class="nx">reached</span><span class="p">;</span>
</code></pre>
</div>

<p><a name="counter_program"></a></p>

<h6 id="counter-program-to-evaluate-the-product-x-x-y-with-a-b-c-labels">Counter program to evaluate the product <code class="highlighter-rouge">x</code> x <code class="highlighter-rouge">y</code> (with <code class="highlighter-rouge">A, B, C</code> labels</h6>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// initialise some vars.</span>
<span class="nx">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// finished product</span>

<span class="nl">A</span><span class="p">:</span> <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">goto</span> <span class="nx">C</span><span class="p">;</span> <span class="c1">// end of outer for loop</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// perform this loop x times</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// each time around the loop we set v = y</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="nx">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// in a slightly contrived way</span>
  
<span class="nl">B</span><span class="p">:</span> <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">goto</span> <span class="nx">A</span><span class="p">;</span> <span class="c1">// end of inner for loop</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="nx">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// perform this loop v times</span>
  <span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// each time incrementing z, so really add y to z by end of inner loop</span>
  
  <span class="k">if</span> <span class="nx">u</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">goto</span> <span class="nx">B</span><span class="p">;</span> <span class="c1">// return to start of inner loop</span>
  
<span class="nl">C</span><span class="p">:</span> <span class="nx">halt</span><span class="p">;</span>
</code></pre>
</div>

        </section>

        

        <footer class="post-footer">
            <!-- If we want to display author's name and bio -->
            
            
                <figure class="author-image">
                    <a class="img" href="/cs-notes" style="background-image: url(/cs-notes/assets/images/profile.png)">
                    <span class="hidden">Dasha Shumitskiy's Picture</span></a>
                </figure>
                <section class="author">
                    <!-- Author Name -->
                    <h4> Dasha Shumitskiy </h4>
                    <!-- Author Bio -->
                    <p>
                        Here goes the author description. You might want to place some links too in here
                    </p>
                </section>
            

            <!-- Disqus comments -->
            

        </footer>

    </article>

</main>

    <footer class="site-footer clearfix">
      <section class="copyright">
        <a href="/cs-notes">Computer Science Notes</a> &copy; 
              2018 &bull; All rights reserved.
      </section>
      <section class="poweredby">Made with Jekyll using 
        <a href="http://github.com/rosario/kasper">Kasper theme</a>
      </section>
    </footer>
    
    <script type="text/javascript" src="/cs-notes/assets/js/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="/cs-notes/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/cs-notes/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-108074430-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>   
</body>
</html>
